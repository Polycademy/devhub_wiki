====== PHP - Server Side Architecture ======

PHP is a server side scripting language. It is a dynamic and interpreted language. PHP is not compiled. It runs through an interpreter, which is usually a PHP processor module that is integrated into a web server. For our purposes, that would be the Apache HTTP server which includes ''mod_php'' as the processor module. PHP can also be ran as CGI, but that is not as common as the ''mod_php'' method. It started out being an embedded scripting language to HTML, but grew into a full fledged programming language. It includes its own command line interface and can run as a stand alone server (but only used for development). It is single threaded and share nothing, meaning that it doesn't natively support concurrent processing and it doesn't share data between processes. PHP is currently the most widely used web programming language powering Wikipedia, Facebook, Digg and more. 

While going through this article, try using [[http://phpbounce.aws.af.cm|PHPBounce]] to quickly test out your code if you don't have a chance to run a web server.

===== Object Oriented Programming (OOP) =====

There four fundamental [[wp>Programming paradigm|programming paradigms]]. They are object-oriented, imperative, functional and logic programming. PHP can support multiple paradigms, namely procedural (imperative) and object oriented. It incorporates aspects of functional, but developers don't architect their PHP applications in a functional way. The most common programming paradigm for PHP is object oriented.

Object oriented simply means that we try to separate our programming into logical units of code. Each unit of code is an object. Each object can have multiple data properties that describe the object and multiple functions called methods. When we normally start programming, we naturally start in a procedural manner, specifying a list of tasks and subroutines before getting an end result. However in OOP, each object is an independent unit of code capable of receiving input, processing data and returning output. Each object can call on other objects, be dependent on external objects, or extended from parent objects. Each object has a distinct role. The decision of how granular we want when separating code into objects depends on the complexity of the unit of code. If you can find yourself doing multiple different //types// of tasks in one subroutine, then it's probably time to separate each //type// of functionality into different objects or different object methods. Objects should be created with one single responsibility, one way to check if an object is doing too many things is checking how many ''if'' or ''switch'' statements that are used to branch off logic. This is called the [[wp>Single responsibility principle|Single Responsibility Principle]]

In order to create objects, we actually first specify a class. Classes are blueprints for objects. Objects are actually //instances// of classes. So a single class can be used to create multiple objects. Note that the words objects and classes are used interchangeably. However when people say class it usually refers to the creation of the class, whereas when people refer to object, it usually refers to instantiated context of the class.

It's important to note that by convention we name our classes with capitalised first letters and the rest [[wp>CamelCase|camel cased]]. Except when we're naming interfaces or abstracts. Furthermore we put each class into its own single file, so there's never two classes in one file. The file name should also match the name of the class including the capitalisations. This file naming convention however is not applied when we're using models, views or controllers in Codeigniter. The reason for this is due to a mismatch of conventions between the PSR autoloading standards and Codeigniter.

<code php>
//a class of Elephant, classes are usually capitalised
class Elephant{}

//$elephant is an object instance of the Elephant class
$elephant = new Elephant;
</code>

OOP has four main concepts: encapsulation, abstraction, inheritance and polymorphism. 

==== Encapsulation ====

OOP arose from the need to modularise and separate the functionality of software as software grew in complexity. The OOP approach encourages encapsulation which means we should place units of data inside objects which can only be accessed and manipulated through the object's methods. The methods act as intermediaries between different objects. You should never access data properties from the object directly.

The motivation for encapsulation is discipline and abstraction. By encapsulating the data properties and thus the state of the object, we're hiding the implementation details of the object, but instead providing an method API that external objects can access. This helps with the abstraction process by providing a consistent way of accessing objects. This discipline is also useful when software development takes place in teams.

Furthermore since the data properties are hidden, and only the names of methods are accessible, we can change the implementation details of the object without worrying of breaking the API for other objects.

<code php>
class Elephant{

    //encapsulated private data property of $_colour. The private makes it only accessible within the object's instance using $this. This underscore is only a convention of prefixing private or protected variables.
    private $_colour;
    
    //public accessor method that sets the $_colour and echos it
    public function set_colour($colour){
        
        $this->_colour = $colour;
        echo $colour;
        
        //did you know that we can dynamically create object instance variables too? This only gets created when set_colour is called from the instance
        $this->hue = $colour;
        
    }
  
}

$red_elephant = new Elephant;
//we can access the public method that acts as the intermediary to the private data property
$red_elephant->set_colour('red');

//second object instantiation
$green_elephant = new Elephant;
$green_elephant->set_colour('green');
echo $green_elephant->hue;
</code>
==== Abstraction ====

Encapsulation is actually technique of a more generic concept called abstraction. Objects should be abstracted. This means that the concrete implementation details should be hidden and abstracted away, so that only contextually important methods are available at a particular perspective. Here's a couple examples: the concept of a "List" is an abstraction of "Fruit List" or "Car List". The concept of a "Living Thing" is an abstraction of "Animals" which is an abstraction of "Dog". The concept of "People" is an abstraction of the person "Roger" and "Matthew". When constructing an object, the available object properties should be relevant to the context of which it is used. All "People" may have heights and weights, but only "Roger" has a preference for "Action Movies" and only "Matthew" has a tattoo saying "I'm Awesome". So when I'm defining the "People" object, it should not have properties of movie preferences or tattoos, those are not contextually relevant to how I would perceive or represent "People" as an abstract concept.

Abstraction is achieved by encapsulating concrete implementation details, but it can also be achieved by leaving concrete implementation details later to extend the abstract class as the parent class.
==== Inheritance ====

Inheritance can be used to establish an abstract hierarchy of concepts and objects. At the same time because we're not rewriting the parent class's code, we enhance code reuse. Essentially child classes can inherit from parent classes, so that it inherits its parent's properties and methods.

Methods specified in the parent classes can be overwritten by child classes unless finalised with ''final //scope// function //name//{}''. PHP also does not support multiple inheritance, so a child can only inherit from one parent. However there are different strategies to overcome this. Classes can also chain inheritance.

<code php>
class Animal{

    //private scoped variables will not be accessible in the child classes
    private $_exists = true;
    
    //protected scoped variables are accessible in the child class but not outside of the class
    protected $_breathing_noise = 'breathing';
    
    public function breathe(){
        echo $this->_breathing_noise;
    }
    
}

//Elephant is a child of the abstract parent Animal class
class Elephant extends Animal{
    
    private $_colour;
    
    public function set_colour($colour){
        //$this can access this class and the parent's class when the object is instantiated
        $this->_colour = $colour;
        echo $colour;
    }
    
    public function set_breathing($noise){
        $this->_breathing_noise = $noise;
    }
    
}
     
$elephant = new Elephant;
$elephant->set_colour('red');
$elephant->set_breathing('HRRUMPH!');
$elephant->breathe(); //look accessing the parent's method!
</code>

==== Polymorphism ====

Simply put polymorphism is simply that classes can have different functionality and yet share the same interface. Essentially you would be able to call a method that has a name, that is shared by classes which occupy the same abstraction level, but have different functionality. The point is so that you can write less code by not having to specify ''if'' statements to switch functionality based on some context. This also means when you're working in teams you can establish a standard for API methods for similar classes.

An example would be a button. Everybody knows how to interact with a button. You either press it or you don't. But what the button does, who knows? So all buttons should have the same interface, such as a method called ''press''.

Polymorphism is supported by two extra constructs: Interfaces and Abstracts.

=== Interfaces ===

Interfaces are contracts that objects implement. An object can implement multiple interfaces. An interface is simply an empty class with named methods, but no implementation details inside the methods. Any class that implements an interface will have to create concrete methods that match the empty methods in the interface, it they don't, it will cause a fatal error. By using interfaces you're guaranteeing that your implemented objects will have a set of public API methods.

Interfaces support polymorphism because different objects can implement the same interface. If we take the button example, there could be a button interface, which red button and green button implements.

<code php>
//We usually prefix our interfaces with i, and class names are usually camelcased
interface iButton{
    
    public function press();
    
    public function change_colour();
    
}

class RedButton implements iButton{

    public function press(){
        echo 'Alert! RED BUTTON PRESSED!';
    }
    
    public function change_colour(){
        echo 'Flash RED and ORANGE!';
    }

}

class GreenButton implements iButton{

    public function press(){
        echo 'Warning! GREEN BUTTON PRESSED!';
    }
    
    public function change_colour(){
        echo 'Flash GREEN and BROWN!';
    }

}

//now we can expect the same API methods, and hence polymorphic method! Same name, different functionality.
$red = new RedButton;
$red->press();
$green = new GreenButton;
$green->press();
</code>

Interfaces can also include constants which are accessible statically in their implementing objects. See the [[#using_libraries|Using Libraries]] section for more on static classes. Interfaces can also be extended, this allows interfaces to occupy multiple levels of abstraction. You can have a ''interface iLivingThing'' which is an abstraction of ''interface iAnimal''.

Interfaces are most commonly used with type hints to enforce type checking when injecting dependencies. See [[PHP - Design Patterns]] for more information on dependency injection.

<code php>
interface iAdd{

    //interfaces can also demand parameters
    public function add($one, $two);

}

class Calculator implements iAdd{

    public function add($one, $two){
        $result = $one + $two;
        return $result;
    }

}


class Calculation{

    //the iAdd type hint here forces the $calculator to be any object that implements the iAdd interface, because Calculation is expecting the add method which is guaranteed by the iAdd interface
    //__construct methods are called as soon as the class is instantiated, its parameters dictate parameters that are passed during object instantiation
    public function __construct(iAdd $calculator, $one, $two){
        $result = $calculator->add($one, $two);
        echo $result;
    }
    
}

//if I passed in an object that didn't implement the iAdd interface, the typehint would cause a fatal error
//you may notice that this object instantiation has parentheses "()", these are used when there is a __construct method, which is called as soon as the object is instantiated
$calculation = new Calculation(new Calculator, 5, 6);
</code>

The practice of using interfaces with type hinting and dependency injection is important, as it modularises the dependencies of classes. The Calculation class depends on an object that implements the iAdd interface. It doesn't care what the passed in object is, as long as it has the methods specified in the interface, because it's expecting to use those methods. Therefore, this also loosens the dependency coupling, allowing us to swap out the Calculator object with a different object with different implementation details as long as it preserves the polymorphic method names and expected output.

This practice is quite useful when you need to abstract the API (the way you use something) away from the concrete implementation (what the something is). One example would be if you're using a class that needs to store data into a database. That class should not care what kind of database it is, and how it stores its data as long as it has access to a set of predictable API methods. If you hard coded the database dependency and decided to change the database some time later, then you would have to change all the method calls, which is not good for maintenance. By using an interface, you avoid all of that by simply swapping out the database class and implementing the interface. Of course this only works if you abide by type hinting and dependency injection.

Note that objects can implement multiple interfaces, this just makes the instantiation of the object more strict, in that they have to implement all the methods specified in the interfaces.

=== Abstracts ===

Abstracts are interfaces that allow concrete implementations of their methods, however classes extend abstracts instead of implementing them, this means only one abstract can be used for each object. You might then think why can't we just use a normal class and have children that extend it. Well you could, but in programming, it's good to be explicit. Think of abstracts as a strict possessive parent class that must have children, and then forces its children to do things their way. But at the same time, it provides shared methods to their children to use. Hence abstracts are never used by themselves.

Developers use abstracts to provide a boilerplate classes. Abstract methods which are the ones that children are forced to implement have to be either scoped at protected or public. Private wouldn't work.

<code php>
//abstracts are classes, that's why we still have a class operator, furthermore we prefix abstracts with a little a
abstract class aArmor{

    //shared variable
    //variables or properties cannot be abstracted, they are considered concrete implementation details
    protected $_weight;
    
    //shared method
    public function set_weight($kg){
        $this->_weight = $kg;
    }
    
    //this is what will have to be implemented by the children
    abstract public function armor_rating();
    
}

class ChineseArmor extends aArmor{

    public function __construct($weight){
        $this->set_weight($weight);
    }
    
    
    //implemented functions have to be at the same or less restrictive scoping, public is the least restrictive!
    public function armor_rating(){
        echo 'Over 10,000!';
    }
    
    public function get_weight(){
        echo $this->_weight;
    }

}

$armor = new ChineseArmor('100 Kg');
$armor->armor_rating();
$armor->get_weight();
</code>

Abstracts can also be type hinted, in fact all objects can be type hinted, so you can use them in the same way as interfaces with dependency injection.

Abstracts can also be used with interfaces.

<code php>
interface iPhysicalObject{

    //abstracts do not need to implement this, only the final concrete child class
    public function weight();

}

abstract class aArmor implements iPhysicalObject{

    //shared function
    public function armor_rating(){
        //abstracts can reference weight method even though it doesn't exist yet, because it has been guranteed by the interface
        $rating = 10 * $this->weight();
        return $rating;
    }
    
    abstract public function blacksmith();

}


class ChineseArmor extends aArmor{

    //defined by interface
    public function weight(){
        return 100;
    }
    
    //defined by abstract
    public function blacksmith(){
        echo 'The Yellow Dragon!';
    }
    
    public function protection(){
        $protection = $this->armor_rating();
        //if the armor was created by the The Yellow Dragon! we add a bonus of 1000
        if($this->blacksmith() == 'The Yellow Dragon!'){
            $protection + 1000;
        }
        return $protection;
    }

}


class Fight{

    public function __construct(aArmor $armor){
        if($armor->protection() > 100){
            echo 'You won!';
        }
    }

}

$battle = new Fight(new ChineseArmor);
</code>
===== Model View Controller (MVC) =====

The model view controller pattern is an architecture pattern that separates software applications into three areas. The model is the business logic and application data. The view is the presentational user interface of the data. The controller is what binds the model's data to the view inputs, and it also routs user input requests to the appropriate interactions. The central ideas of the MVC pattern is [[wp>Code reuse|code re-usability]], [[wp>Separation of concerns|separation of concerns]] and [[http://www.slideshare.net/damiansromek/thin-controllers-fat-models-proper-code-structure-for-mvc|thin controllers - fat models]].

MVC architecture is usually placed behind a [[wp>Front Controller pattern|front controller]]. These front controllers essentially establish the workflow and middleware for every request and response. The front controller may include a router, or the router may be part of the middleware. The router routs requests to the appropriate controller which then calls upon its models and views to produce a response.

Codeigniter is an MVC framework. The code you write is separated into models, views and controllers. We also further separate our code into libraries, packages and helpers, but that's for later. Codeigniter also includes a front controller which is the index.php at your project root. Codeigniter automatically routs requests in the URL to the controller with a matching name, however this can be customised in the routes.php. The Apache HTTP server actually sends all requests to the index.php, the index.php then calls upon the rest of the architecture and produces a response. No other files in Codeigniter is accessed directly. This gives an easy way to hook into the request and response flow and introduce middleware.

Note that there is a many to many relationship between models, controllers and views. One controller may call upon multiple models and multiple views. Models don't call controllers or views, and views don't call controllers or models. They simply return data to the controller that called them. Therefore models and views can have multiple controllers that interact with them.

Interfaces, abstracts and further inheritance can be applied to Codeigniter's models, views and controllers. However this practice is uncommon. I recommend you to use only these features in libraries or packages, and follow Codeigniter extension suggestions in their userguide if you need customised functionality in the architecture.

{{ :web_application_development:appflowchart.gif |}}

==== Model ====

Your models is where your business logic and application data resides. Your models should contain the bulk of your operations and processing. Models also contain accessors and mutators to your database if any. It's important to understand that models aren't just for storing state, but also the operations on the behaviour of your system. If you were writing a Chess game, not only would the storage of the chess board state be via the model, but also the rule checking algorithms and artificial intelligence. Once this business logic finds itself needed in other areas, that's when you abstract it into its own package or library. That way it can be called and executed in multiple models.

Models return processed data to the controller. Models don't need to know where it gets called, just that it does.

Models can also perform data validation, but data validation that involves simply input filtering for security purposes should be left to the controller, because that's metaphorically the gate to your software fortress. However if the data validation requires business logic to be performed, such as checks against the database, then the it should be placed in the model. However opinions may vary on this suggestion.

Example Codeigniter Model:

<code php>
//by convention we suffix the model with _model and all models extend the CI_Model from Codeigniter
class Blog_model extends CI_Model {

    public function __construct(){
        //when the model gets loaded into the controller, it calls the parent __construct method. This __construct method is actually from CI_Model. This way when we instantiate this object, we also instantiate the parent.
        
        //CI_Model's __construct() is not implicitly called because we method overrided it with this child class's __construct. Therefore in order to setup the parent's class, we need to call it with parent::__construct(). If this model did not have __construct, then the parent's __construct would be automatically called.
        parent::__construct();
        
        //here is where you load any dependencies as well, either through CI's loader or through autoloading
        
    }
    
    public function get_article($id){
        
        //code to get an article out of the database using $id
        
    }
    
    public function add_article($data){
    
        //code to add the article data to the database
    
    }
    
    //more accessors and mutators here...

}
</code>
==== View ====

Your view is where your user interface code lies. Remember that HTML and CSS markup you did while in the Web Design section? Well that HTML markup is going to be cutup into independent layouts in the view. The CSS, Javascript and other assets actually remain where they are. The view is also where we implement [[#templating|templating]], which is the practice of modularising user interfaces into reusable components so they can be swapped in and out with other user interface elements. In order to pull in dynamic data, we actually place variables inside the views which will be injected from the controller after the controller has the data from the model.

By convention we suffix views files with _view. So any file names would like ''home_view.php''.

Example Codeigniter View:

<code html>
<?php defined('BASEPATH') OR exit('No direct script access allowed'); ?>
<html>
    <head>
        <title>Example Page!</title>
    </head>
    <body>
        <p>Hello!</p>
    </body>
</html>
</code>
==== Controller ====

The controller is the manager of the model and view. In Codeigniter the name of the controller corresponds to the first URL segment. The second URL segment is executed as a corresponding method. Any further URL segments are passed the methods as parameters. Controllers are meant to be thin and simply call upon models and pass in parameters, afterwards it binds the returned data to the view and at the same time responds back to the client with the finished data. The only business logic that controllers should have is any input filtering, HTTP routing tasks, and view binding.

Example Codeigniter Controller:

<code php>
//This Home class corresponds to home.php as a filename, home then becomes the first URL segment as http://example.com/index.php/home or http://example.com/home (if using URL rewriting via Apache .htaccess)
class Home extends CI_Controller {

    //you can build up your view binding by creating a privately scoped member array, when you're ready to build up the view, just append values onto this array and pass this to the view. By creating this independent from any methods, the view data is then abstracted and can be added to from multiple methods
    private $_view_data = array();

    //since it is a class that extends the CI_Controller, we still have a __construct that is called as soon as it is initiated
    public function __construct(){
    
        parent::__construct();
        
        //load commonly used dependencies using CI, you would not dependency inject using controllers, because you don't control the calling of controllers
    
    }
    
    //this is the actual method that would be called if there was no second URL segment, it can also be explicitly called by http://example.com/home/index
    //to be callable by URL, they would have to be scoped at public
    public function index(){
    
        //load models and do processing
        //load views and return the response
        $this->load->view('home_view', $this->_view_data);
    
    }
    
    //you can access this via http://example.com/about/2, the 2 becomes the id
    public function about($id){
    
    }
	
}
</code>
===== Templating =====

Templating is the process of using layouts and partials to form complete view user interfaces. In following the separation of concerns, templates should contain as little business logic as possible. It's only there to bring together user interface elements and have dynamic data inserted into them. The problem comes when we want to have reusable partial templates and shared layout templates.

Think of layouts as a template file that specifies the header, footer, sidebar and any other elements that are shared across web pages and hardly change. A large web application may have multiple layouts, one for the blog, one for the administration panel, one for the home page. Each of which may have different headers or lack/include a sidebar. Layouts are the master templates, the templates that specifies other templates.

Think of partials as reusable templates across many different areas. An example would be a table row that may get used in different tables in different pages in different layouts. Partials are the grand children templates, templates that don't specify any other template and doesn't know which parent will pick it up to use it.

There are a number of templating libraries for PHP, some of them catered towards Codeigniter, and others are for generic use. Many of them provide their own domain specific language. You can choose to go with third party solutions, however I like to roll my own simpler solution. PHP after all was a templating language.

So I present to you the static helper class CiTemplating:

  * [[https://github.com/Polycademy/CiTemplating|CiTemplating]]

You can install it via composer (follow the instructions on the README) and it will be autoloaded, allowing you to call it like a global function without the need of instantiating it or using namespaces. Namespaces couldn't be used, due to the nature of templating, it would require an ''use'' namespace import, which would go against the concept of minimal logic views. Please see the section on [[#autoloading|Autoloading]] to find how to integrate autoloading magic into Codeigniter.

To use this library we need to establish some conventions:

  * Each controller you have should have a corresponding folder with a matching name in the view folder. Therefore a controller named ''blog.php'' should have the folder ''views/blog''.
  * Each public method in a controller should have their own view with a matching name stored in their view controller folder. Therefore the controller ''blog.php'' with ''articles'' as a public method should have the view ''views/blog/articles_view.php''.
  * Partials are appended with ''_partial'', and are stored in the partials folder such as ''views/partials/rows_partial.php''.
  * Layouts are appended with ''_layouts'', and are stored in the layouts folder such as ''views/layouts/main_layout.php''.

Your views directory can start to look like this:

  views
    |
    |----layouts
    |       |
    |       |----main_layout.php
    |       |----admin_layout.php
    |       |----json_layout.php
    |
    |----partials
    |       |
    |       |----rows_partial.php
    |
    |----home
    |       |
    |       |----index_view.php
    |
    |----blog
            |
            |----articles_view.php
==== Layouts ====

The CiTemplate static class provide a static ''compose'' method allowing you to define both views and their corresponding layouts. All layouts should inject a ''$yield'' variable. When you run ''Template::compose()'', it will first sent any view data to the specified view, and return the compiled template, before dynamically adding it to the view data array and injecting it into the layout. For example, you should have a ''default_layout.php'' that is like this

<file php default_layout.php>
<?php defined('BASEPATH') OR exit('No direct script access allowed'); ?>
<? Template::partial('header', $header) ?>
<?= $yield ?>
<? Template::partial('footer', $footer) ?>
</file>

The corresponding call to this layout would be something like, if it was called inside the ''index()'' method of a controller..

<code php>
$view_data = array(
    'header' => array(),
    'footer' => array(),
    'data' => 'data_value',
    //... etc
);
Template::compose('index', $view_data);
</code>

The ''$view_data['header']'' and ''$view_data['footer']'' would be be injected into the partial parameters of ''$header'' and ''$footer'' in the layout. The rest of the properties in the view data array would be passed into the ''index_view.php'', and the returned output would automatically be injected into the $yield. This obviously means you should not use have a property key of ''$view_data['yield']'' when defining your view data array, as it would get overwritten.

The compose method also has a third parameter that specifies the layout file to use. By default it is ''default''. The compose method allows you to use full names such as ''Template::compose('index_view', $view_data, 'default_layout');'', but it isn't necessary as it will automatically append ''_view'' or ''_layout'' to the end of the parameter if it doesn't have it. The same goes with partials.

A cool thing you can do with this method is to specify a JSON layout like so:

<file php json_layout.php>
<?php defined('BASEPATH') OR exit('No direct script access allowed');

header('Content-type: application/json');

echo json_encode($yield, JSON_NUMERIC_CHECK | JSON_FORCE_OBJECT);
</file>

You would call this via:

<code php>
//we pass false into the view, because don't need one to pass in straight json_data, json_data has to be an array too!
Template::compose(false, $json_data, 'json');
</code>

To understand how the compose method works, look into the source code of ''Template.php''. It's well documented.
==== Partials ====

Partials allow you define and call in reusable templates within templates. They also allow you to loop through results and repeat a compiled template with minimal logic. Partials are stored in the partials folder. Although it is possible to modify the code to allow partials anywhere in the view directory, I found it more appropriate and simpler to specify that all of them must be in one directory. Do note that it is possible to specify subdirectories in the partials folder though.

Partials are called within template views like so:

<code php>
//first parameter is the name of the partial with or without '_partial' appended to it, second parameter is the variable to pass in
Template::partial('header', $header);
</code>

To loop through results you would need to pass ''true'' to the third parameter in your view file.

<code php>
Template::partial('row', $row_data, true);
</code>

This would call in a partial and attempt the iterate through //values// of the ''$row_data''. The values are by default specified in the partial as ''$row'' variables. It is important to understand this. When you call ''Template::compose()'' to a view that has a looped partial, the view data array you pass in should have a property of which its key name matches the injected parameter of ''Template::partial''. This property needs to also be an array, and its values are what is iterated over and stored in a ''$row'' variable. The partial can simply call ''$row'' if it's a scalar value, but if you need multiple properties in the ''$row'' variable, then the values that are iterated should also be an array.

Imagine you had a controller code like this:

<code php>
$view_data = array(
    'row_data' => array(
        'First Row',
        'Second Row',
        'Third Row',
    ),
);

Template::compose('table', $view_data);    
</code>

Then the view could be:

<code php>
<table>
    <tbody>
        <? Template::partial('row', $row_data, true) ?>
    </tbody>
</table>
</code>

Then the partial would be:

<code php>
<tr>
    <td><?= $row ?></td>
</tr>
</code>

Each of the ''$row'' would contain the scalar string of "First Row", then "Second Row", and finally "Third Row".

If I wanted the ''$row'' to have multiple parameters, then I would change ''$row_data'' to be an array of arrays.

<code php>
$view_data = array(
    'row_data' => array(
        array(
            'name' => 'Roger',
            'id' => '4'
        ),
        array(
            'name' => 'Dave',
            'id' => '5'
        ),
    ),
);

Template::compose('table', $view_data);

//and this would be in the partial

<tr>
    <td><?= $row['name'] ?></td>
    <td><?= $row['id'] ?></td>
</tr>
</code>

As you can see array keys don't matter here.

By default they automatically echo their data as soon as they are called. However you can also specify that they return data as a variable by setting the fourth buffer parameter to true.

<code php>
$partial_compiled = Template::partial('row', $data, false, true);
</code>
===== Using Libraries =====

One the key concepts of OOP is reusing code. Libraries are the primary way of reusing and sharing code. Whereas code in the MVC refers to a specific implementation of a particular web application. Libraries are created independently of what the web application does. Libraries can be a list of procedural functions, however these are usually called helper functions, and since we're using OOP, we should avoid using function lists which are hard to test, maintain, extend and impossible to autoload. Therefore our libraries will either be normal classes, abstract classes, interfaces or static classes.

There are different ways of structuring library classes, most of the ways are dependent on how best to autoload or not autoload the classes, and the usage or non-usage of namespacing. The PSR-0 (composer) standard was all about standardising sharable code libraries that could be autoloaded. However there are a number of other ways including Codeigniter's native library loading functionality, Codeigniter Sparks package management and of course rolling our own autoloading. This section will go through each and also discuss static classes.
==== Codeigniter Libraries ====

Codeigniter allows you to create your own libraries and store them in the ''application/libraries'' folder. Follow the user guide on [[http://ellislab.com/codeigniter/user-guide/general/libraries.html|loading libraries]] and [[http://ellislab.com/codeigniter/user-guide/general/creating_libraries.html|creating libraries]] for more information. For the purposes of autoloading convention, any library we create should be capitalised and camelcased. In the cases of interfaces and abstracts they should be prefixed with an ''i'' or ''a'' respectively. When you load a Codeigniter library using the Codeigniter loader, it will automatically instantiate the class into an object. So static classes will have to be loaded differently.

Codeigniter also provides a number of system libraries available for you to use. They provide a number of default functionality that we can take advantage of in order to avoid reinventing the wheel. Check out [[http://ellislab.com/codeigniter/user-guide/toc.html|Codeigniter's class and helper reference]] for more information. Many of the functionality you need to run a generic web application is already available.

You can also replace and extend system libraries. You will need to either put them into the ''application/core'' or ''application/libraries'' folder. A good way to know, is to go into the ''system/core'' directory and see if the class you're trying to extend is there, and if it is, then it should be in the ''application/core''. This is how people get customised controllers or loaders.

If you're replacing a native library. You would use the same name of the class you're trying to replace. But inside the class, you would call it CI_CLASSNAME. For example to replace the Email class. You would name it ''Email.php'' and have it run as ''class CI_Email{}''.

If you're extending a native library just declare your class as MY_CLASSNAME extending CI_CLASSNAME. Furthermore if you're using a constructor, make sure to call the parent constructor with ''parent::constructor();''.

=== Sparks ===

Before the days of Composer and PSR-0, Codeigniter had its own package and repository manager called Sparks. It is still in use today by legacy Codeigniter libraries and Codeigniter specific packages. So this will still be useful. However it hasn't been kept up to date with the latest develop branch version of Codeigniter, so in order to install we have to make a couple changes. See the [[Solution Stack#sparks|solution stack on sparks]] for more information.

You would have spark packages located at project root, and with the augmented ''MY_Loader.php'' you can load them via ''$this->load->spark('example-spark/1.0.0');'', it is then usable as ''$this->example_spark->method();''. Notice that we can't use hyphens ''-'', when calling methods from classes as it confuses the interpreter as a syntax error. Packages either have to be underscored or camelcased.
==== Composer Libraries ====

Composer is one of the best things to come to PHP since sliced bread. There has been numerous attempts at package management for PHP in the past, but Composer is the best and most widespread in the modern day. Composer is not only an installer tool, but it is also a [[http://phpmaster.com/autoloading-and-the-psr-0-standard/|PSR-0 compliant autoloader]]. What this means it will autoload classes and conform to namespace usage. This allows you to simply call ''new Class'' or typehint interfaces or ''use'' importing without having to actually ''include'' or ''require'' the files that the classes reside in. This magic is performed by modern versions of PHP providing autoload functions that hook into the loading architecture so we can augment it to automatically load what we want given a specified directory, naming style and namespace usage. Composer also allows non-PSR autoloading, so if you have some utility classes that you just want autoloaded, Composer can do that as well.

Try checking out the composer directory, look at how the packages are structured, and the common uses of namespaces in their source code.

However there's a problem. Codeigniter is a framework that caters to older versions of PHP users. So it's not natively integrated into Composer. However there are easy ways of integrating Composer into Codeigniter. Autoloading can be considered a form of bootstrapping. Essentially the autoloader should be available from the very start of initialising a web application. Where is the very start of our MVC architecture? It's in the front controller! So the simplest way of integration would be to simply ''require_once'' the Composer's ''vendor/autoload.php'' in Codeigniter's front controller which is the ''index.php'' at root. It would be [[http://pastebin.com/6ffYwdkf|somewhere at the end but before Codeigniter loads all the controllers]], or else we'd try to load classes before the autoloader is registered.

However there is a better way, and in fact this "Polycademy" way actually gives us autoloading on your Codeigniter's ''application/libraries'' and ''application/third_party'' for free, and is more semantic with Codeigniter's architecture.
==== Autoloading ====

Codeigniter provides a [[http://ellislab.com/codeigniter/user-guide/general/hooks.html|hook API]] so we can plug in our own middleware. The one we're interested in is the most earliest, that is the pre-system hook. This is where we're going to place our Composer bootstrap and our own PSR-0 compliant autoloader.

  - Enable hooks in ''config/config.php''.
  - In your ''config/hooks.php'' define: <code php hooks.php>
//pre_system autoloader
$hook['pre_system'] = array(
    'class' => 'Autoloader',
    'function'  => '__construct',
    'filename'  => 'Autoloader.php',
    'filepath'  => 'hooks',
);
</code>
  - Then download this [[https://github.com/Polycademy/CiAutoloading|Autoloader.php]] into ''application/hooks/Autoloader.php''. (You should also try to read and understand the code, refer to documentation for commands you don't know).

Now you can auto instantiate objects and call static methods from static classes anywhere, and that means both packages in Composer and packages/libraries in your ''application/libraries'' or ''application/third_party''. However when constructing your library classes, do not use underscores in your filenames (excepting folder names) as they will be translated into directories. You need to follow the [[https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md|PSR-0 rules]] now. Capitalised and camelcased!

However if you classes that extend CI's native classes, you will not be able to autoload them. This is because the system classes that your classes are extending/replacing are not autoloaded as they are in the system directory. You'll need to use the native loader to load them. This does not conflict with the native loader.

At this point you have a flexible system utilising Composer, Sparks, Native CI and your own PSR-0 or class map loader.

In order to autoload classes in directories, you'll have to use namespaces.
==== Namespaces ====

Vendor/Package/Library style naming.

If the "use" keyword only points to a directory and not to a specific file, that all of those files become fair game. However you need to use the last namespace directory and prefix to all class initialisations. Like use Phpbounce\Mission_checker;
Then your initialisations would be new Mission_checker\Lint(); There's no need to specify the filenames. The filenames should always be the same as the class names. One class per file.

Talk about usage of Abstracts and Interfaces in non-package specific

==== Static Classes =====

Static classes are actually classes that have static member properties or methods. These properties and methods can be called without instantiating the class. They pretty much do the same thing a procedural function list, however they are more flexible to use and more consistent with OOP usage.

Static classes are alternatives to procedurally defining a large amount of helper functions that simply operate on data without storing any state itself. It's better to use static classes in OOP simply for two reasons. Consistency in software architecture and the fact that static classes can be autoloaded whereas function lists cannot. There will never be multiple instances of a static class because it doesn't store any state, you can use the same function for everything because it just operates of other things. Using the self:: way of calling static methods/variables also enforces a class scope and disciplines you towards single responsibility principle.

Why static classes? So static classes would usually be put in the helpers because they are not instantiated and CI's loader auto instantiates what it loads. However with the addition of an autoloader, we would instead put our static classes in the libraries folder.

<code>
class lol{

	public static $auto = 'WHDFD';

	public function what(){
		$this->auto = 'auto';
	}

	public function no(){
		echo self::$auto;
		echo $this->auto;
	}

}

$lol = new lol;
$lol->what();
$lol->no();

</code>

Static methods and variables or static classes:
1. Access static classes via self::$auto when inside the class. The self refers to the class, not the object. If you're calling static, you have use the fullname of the variable hence the $ at the start. When calling it as an object, you can just use the member name without the $. Such as $this->auto;
2. If the method is static, you can still instantiate the object and use it. But the $this will not be available inside the static class.
3. self:: will always refer to the variable when it was declared in the class.
4. self:: will not work when dynamically instantiating object instance properties or variables. Because they were not statically defined in the class.

===== Database =====

==== SQL and NoSQL ====

Explain difference between SQL and NoSQL

Intro to mysql, and why we should use active records or PDO

Transactions and ATOMICITY

==== Active Records ====

Explain framework usage and PDO

Also abstraction of different databases into a set standard API.

Also singleton pattern.

==== Search ====

Full text search

Using Sphinx

==== Redis ====

Non-Persistent (volatile data)

Caching with Redis

Sessions with Redis
===== Security =====

Should make a security "checklist" before deployment.

==== Input Validation ====

Escaping

Testing against rules

SQL injection

==== CSRF ====


Handling Passwords

==== Handling Passwords ====

Salting

Bcrypt encryption

==== Payments & Credit Cards ====

In short don't bother. Leave it to the experts. Have a third party process transactions and SSL at all times

==== SSL ====

For transmitting any sensitive information
===== Sessions & Authentication =====

Cursory note about AJAX

==== Sessions ====

Cookie based

URL based

PHP Session based

Database based (best!) using Redis

==== Authentication System ====

Login password matching

Permissions using group system and bitwise operators

==== AJAX ====

Can use normal sessions

Can use REST based authentication using API key (but more for providing external service_

Username & Login on each request

Using Oauth and Oauth2 but refer to providing web services
===== .htaccess =====

For apache

URL rewriting

GZIP Compression

===== Caching =====

==== Opcode Caching ====

Alredy done by APC

==== View File Caching ====

Include partial or fragment caching

==== Database Caching ====

Caching database calls, but also storing data into a database that is sometimes called from external web services

Using either Redis (also memory) or MongoDB

==== Browser Caching ====

Using .htaccess
===== Concurrent Processing =====

Multithreading PHP is not multithreaded

For offloading work (image thumbnailing), distributing work (getting data from multiple places).

Using daemons

Using ZMQ

Using Gearman workers

A note due to host environments, you may not able to use daemons, zmq or gearman. You may then have to use hacks, or use dotCloud's workers. Or thirdparty the workers.

Use Supervisor to keep track of tasks

===== Consuming Web Services APIs =====

Using REST

Oauth

Oauth2

===== Providing Web Services APIs =====

REST provision

Oauth Provision

JSON

Pusher API

===== Sockets & RTC =====

Sockets using Ratchet (daemons) (Pub/Sub) and HAProxy (Ratchet can provide an always on subscriber or publisher..?)

RTC (tokbox) and UDP and TCP
====== PHP - Server Side Architecture ======

PHP is a server side scripting language. It is a dynamic and interpreted language. PHP is not compiled. It runs through an interpreter, which is usually a PHP processor module that is integrated into a web server. For our purposes, that would be the Apache HTTP server which includes ''mod_php'' as the processor module. PHP can also be ran as CGI, but that is not as common as the ''mod_php'' method. It started out being an embedded scripting language to HTML, but grew into a full fledged programming language. It includes its own command line interface and can run as a stand alone server (but only used for development). It is single threaded and share nothing, meaning that it doesn't natively support concurrent processing and it doesn't share data between processes. PHP is currently the most widely used web programming language powering Wikipedia, Facebook, Digg and more. 

While going through this article, try using [[http://phpbounce.aws.af.cm|PHPBounce]] to quickly test out your code if you don't have a chance to run a web server.

===== Object Oriented Programming (OOP) =====

There four fundamental [[wp>Programming paradigm|programming paradigms]]. They are object-oriented, imperative, functional and logic programming. PHP can support multiple paradigms, namely procedural (imperative) and object oriented. It incorporates aspects of functional, but developers don't architect their PHP applications in a functional way. The most common programming paradigm for PHP is object oriented.

Object oriented simply means that we try to separate our programming into logical units of code. Each unit of code is an object. Each object can have multiple data properties that describe the object and multiple functions called methods. When we normally start programming, we naturally start in a procedural manner, specifying a list of tasks and subroutines before getting an end result. However in OOP, each object is an independent unit of code capable of receiving input, processing data and returning output. Each object can call on other objects, be dependent on external objects, or extended from parent objects. Each object has a distinct role. The decision of how granular we want when separating code into objects depends on the complexity of the unit of code. If you can find yourself doing multiple different //types// of tasks in one subroutine, then it's probably time to separate each //type// of functionality into different objects or different object methods.

In order to create objects, we actually first specify a class. Classes are blueprints for objects. Objects are actually //instances// of classes. So a single class can be used to create multiple objects.

<code php>
//a class of Elephant, classes are usually capitalised
class Elephant{}

//$elephant is an object instance of the Elephant class
$elephant = new Elephant();
</code>

OOP has four main concepts: encapsulation, abstraction, inheritance and polymorphism. 

==== Encapsulation ====

OOP arose from the need to modularise and separate the functionality of software as software grew in complexity. The OOP approach encourages encapsulation which means we should place units of data inside objects which can only be accessed and manipulated through the object's methods. The methods act as intermediaries between different objects. You should never access data properties from the object directly.

The motivation for encapsulation is discipline and abstraction. By encapsulating the data properties and thus the state of the object, we're hiding the implementation details of the object, but instead providing an method API that external objects can access. This helps with the abstraction process by providing a consistent way of accessing objects. This discipline is also useful when software development takes place in teams.

Furthermore since the data properties are hidden, and only the names of methods are accessible, we can change the implementation details of the object without worrying of breaking the API for other objects.

<code php>
class Elephant{

    //encapsulated private data property of $_colour. The private makes it only accessible within the object's instance using $this. This underscore is only a convention of prefixing private or protected variables.
    private $_colour;
    
    //public accessor method that sets the $_colour and echos it
    public function set_colour($colour){
        $this->_colour = $colour;
        echo $colour;
    }
  
}

$red_elephant = new Elephant();
//we can access the public method that acts as the intermediary to the private data property
$red_elephant->set_colour('red');

$green_elephant = new Elephant();
$green_elephant->set_colour('green');
</code>
==== Abstraction ====

Encapsulation is actually technique of a more generic concept called abstraction. Objects should be abstracted. This means that the concrete implementation details should be hidden and abstracted away, so that only contextually important methods are available at a particular perspective. Here's a couple examples: the concept of a "List" is an abstraction of "Fruit List" or "Car List". The concept of a "Living Thing" is an abstraction of "Animals" which is an abstraction of "Dog". The concept of "People" is an abstraction of the person "Roger" and "Matthew". When constructing an object, the available object properties should be relevant to the context of which it is used. All "People" may have heights and weights, but only "Roger" has a preference for "Action Movies" and only "Matthew" has a tattoo saying "I'm Awesome". So when I'm defining the "People" object, it should not have properties of movie preferences or tattoos, those are not contextually relevant to how I would perceive or represent "People" as an abstract concept.

Abstraction is achieved by encapsulating concrete implementation details, but it can also be achieved by leaving concrete implementation details later to extend the abstract class as the parent class.
==== Inheritance ====

Inheritance can be used to establish an abstract hierarchy of concepts and objects. At the same time because we're not rewriting the parent class's code, we enhance code reuse. Essentially child classes can inherit from parent classes, so that it inherits its parent's properties and methods.

Methods specified in the parent classes can be overwritten by child classes unless finalised with ''final //scope// function //name//{}''. PHP also does not support multiple inheritance, so a child can only inherit from one parent. However there are different strategies to overcome this. Classes can also chain inheritance.

<code php>
class Animal{

    //private scoped variables will not be accessible in the child classes
    private $_exists = true;
    
    //protected scoped variables are accessible in the child class but not outside of the class
    protected $_breathing_noise = 'breathing';
    
    public function breathe(){
        echo $this->_breathing_noise;
    }
    
}

//Elephant is a child of the abstract parent Animal class
class Elephant extends Animal{
    
    private $_colour;
    
    public function set_colour($colour){
        $this->_colour = $colour;
        echo $colour;
    }
    
    public function set_breathing($noise){
        $this->_breathing_noise = $noise;
    }
    
}
     
$elephant = new Elephant();
$elephant->set_colour('red');
$elephant->set_breathing('HRRUMPH!');
$elephant->breathe();
</code>

==== Polymorphism ====

Simply put polymorphism is simply that classes can have different functionality and yet share the same interface. Essentially you would be able to call a method that has a name that is shared by classes which occupy the same abstraction but have different functionality. The point is so that you can write less code by having to specify ''if'' statements to switch functionality based on some context. This also means when you're working in teams you can know that the classes with have the same kinds of APIs even though they do different things, especially when they are all used in the same ways.

An example would be a button. Everybody knows how to interact with a button. You either press it or you don't. But what the button does, who knows? So all buttons should have the same interface, such as a method called ''press''.

Polymorphism is supported by two extra constructs: Interfaces and Abstracts.

=== Interfaces ===

INTERFACES why? -> For teams and for dependency injection.
Basically you type hint in the constructor for an object to be injected but also to implement a interface contract.
The interface is like the blueprint for your classes.
You can be assured that all classes implementing this interface will have a fixed API.
Then if you are swapping out your classes to something else, you can pass in a new object that still implements that interface, and you don't have to worry about whether the API methods change. They still work the same.
Interfaces can be combined too, to provide some sort of super class implementation. So this class can be used anywhere or either-or. Regardless of whether the type hint is for the first interface or for the second interface. It'll still work!

Use interfaces to group related classes that are meant to have the same API.

=== Abstracts ===

Use abstracts to provide a boilerplate class. Like a parent class which has some common methods, and yet has methods that has to be implemented. Abstract methods have to be either protected or public which then has to be represented. You can only inherit from one abstract.

Use abstracts as a **parent class that needs to have children**. Not just any standard parent class.

Like abstract armor -> chinese armor, european armor. Abstract armor and abstract sword can implement physical_object interface. The interface can specify that all physical_objects need weight method. The abstract armor leaves the weight undefined, but requires an abstract of blacksmith and defines a common function of armor rating calculation. Then Chinese_Armor extends abstract Armor. This creates the weight function as defined by interface and blacksmith function as defined by the abstract. It creates a protection function unique to Chinese_Armor. Then we create a Fight function that type hints for either Physical Object, or Ab_Armor. We create the Chinese_Armor and pass the dependency into the constructor dependency injection. Then in the fight we use the protection function. Note that the abstract can reference $this->weight even though it hasn't been defined, this is because the interface says it will be implemented, so the abstract can rely on this. Abstracts are never used by themselves.

===== Model View Controller =====

Diagram of MVC including a router

Separation of concerns

==== Model ====

==== View ====

==== Controller ====

===== Templating =====

What is templating

===== Using Libraries =====

CI style

Composer

Sparks

Namespaces

Autoloading

Autoloading works with Codeigniter aswell.

You need to enable hooks on the config.php.

Then in hooks.php define

<code php hooks.php>
//pre_system autoloader
$hook['pre_system'] = array(
    'class' => 'Autoloader',
    'function'  => '__construct',
    'filename'  => 'Autoloader.php',
    'filepath'  => 'hooks',
);
</code>

Place this into the hooks directory. It is a PSR-0 compliant autoloader.
Do not use underscores in your library names, (_). They will be translated into directories.
All folders and files should be Capitalised and Camelcased.
Interfaces and Abstracts can be placed as iInterface or aAbstract and polaced in Interface and Abstract folder.
Use namespaces and use "use" to import aliases. Import straight to the file. Then initialise classes automagically. Use fully qualified names to access static classes or library classes.
Place static classes in the library folder.
Capable of using third_party too.
Folder names can have underscores.

If the "use" keyword only points to a directory and not to a specific file, that all of those files become fair game. However you need to use the last namespace directory and prefix to all class initialisations. Like use Phpbounce\Mission_checker;
Then your initialisations would be new Mission_checker\Lint(); There's no need to specify the filenames. The filenames should always be the same as the class names. One class per file.

===== Database =====

SQL

NoSQL

Persistent vs Non-Persistent (volatile data)

Caching with Redis or session data

Transactions and ATOMIC

Searching with full text

===== Security =====

Should make a security "checklist" before deployment.

Input validation + CSRF

Handling Passwords

Handling payments and credit cards

===== Sessions & Authentication =====

Cursory note about AJAX.

===== .htaccess =====

For apache

URL rewriting

GZIP Compression

===== Caching =====

Database Caching

View Caching

APC Opcode Caching

File caching

Memcache

===== Concurrent Processing =====

Multithreading PHP is not multithreaded

For offloading work (image thumbnailing), distributing work (getting data from multiple places).

Using daemons

Using ZMQ

Using Gearman workers

A note due to host environments, you may not able to use daemons, zmq or gearman. You may then have to use hacks, or use dotCloud's workers. Or thirdparty the workers.

Use Supervisor to keep track of tasks

===== Consuming Web Services APIs =====

Using REST

Oauth

Oauth2

===== Providing Web Services APIs =====

REST provision

Oauth Provision

JSON

Pusher API

===== Sockets & RTC =====

Sockets using Ratchet (daemons) (Pub/Sub) and HAProxy

RTC (tokbox) and UDP and TCP
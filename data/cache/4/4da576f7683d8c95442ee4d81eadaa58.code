<span class="co1">//assume autoloading is setup</span>
&nbsp;
<span class="co1">//ok so this file is in Guzzle/Url directory</span>
<span class="kw2">namespace</span> Guzzle\Url<span class="sy0">;</span>
&nbsp;
<span class="co1">//we're importing something we want to use</span>
<span class="kw2">use</span> Guzzle\Cookie\CookieParser<span class="sy0">;</span>
&nbsp;
<span class="co1">//here we're importing, but we're aliasing it too!</span>
<span class="kw2">use</span> Guzzle\Message <span class="kw1">as</span> Awesome<span class="sy0">;</span>
&nbsp;
<span class="co1">//here we're importing a directory, just imagine that it is a directory and not a file</span>
<span class="kw2">use</span> Guzzle\Directory<span class="sy0">;</span>
&nbsp;
<span class="kw2">class</span> Mapper<span class="br0">&#123;</span>
&nbsp;
    <span class="kw2">public</span> <span class="kw2">function</span> __construct<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#123;</span>
&nbsp;
        <span class="co1">//there's never any need to specify filename extensions, the classes and files are the same name.</span>
&nbsp;
        <span class="co1">//this works, because we imported the file (remember that class names should match file names)</span>
        <span class="co1">//it first looks at the current namespace, then the imported namespace</span>
        <span class="co1">//this is called an unqualified name</span>
        <span class="re0">$cookie_parser</span> <span class="sy0">=</span> <span class="kw2">new</span> CookieParser<span class="sy0">;</span> 
&nbsp;
        <span class="co1">//this may work, it's not imported, so the current namespace gets appended</span>
        <span class="co1">//it will only work if there was a Guzzle/Url/UrlParser.php</span>
        <span class="co1">//this is also called an unqualified name</span>
        <span class="re0">$url_parser</span> <span class="sy0">=</span> <span class="kw2">new</span> UrlParser<span class="sy0">;</span>
&nbsp;
        <span class="co1">//this is called a qualified name, the current namespace gets appended to it</span>
        <span class="co1">//it becomes Guzzle\Url\Another\Parser.php</span>
        <span class="re0">$another_parser</span> <span class="sy0">=</span> <span class="kw2">new</span> Another\Parser<span class="sy0">;</span>
&nbsp;
        <span class="co1">//this is called a FULLY qualified name, it does not append any of the current namespaces, and it does not recognise imported namespaces. It's like an absolute path.</span>
        <span class="re0">$absolute_parser</span> <span class="sy0">=</span> <span class="kw2">new</span> \Other\Cool\Parser<span class="sy0">;</span>
&nbsp;
        <span class="co1">//this uses an alias, and resolves to Guzzle\Message\Parsing.php</span>
        <span class="re0">$aliased_parser</span> <span class="sy0">=</span> <span class="kw2">new</span> Awesome\Parsing<span class="sy0">;</span>
&nbsp;
        <span class="co1">//this is not an alias, instead it points to the Directory import. So it resolves as Guzzle\Directory\SuperParser;</span>
        <span class="re0">$directory_parser</span> <span class="sy0">=</span> <span class="kw2">new</span> Directory\SuperParser<span class="sy0">;</span>
        <span class="co1">//therefore if the use keyword points to a directory and not to a specific file, all of those files become fair game. However you need to use the last namespace directory and prefix all class initialisations</span>
&nbsp;
    <span class="br0">&#125;</span>
&nbsp;
<span class="br0">&#125;</span>
a:772:{i:0;a:3:{i:0;s:14:"document_start";i:1;a:0:{}i:2;i:0;}i:1;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"PHP - Design Patterns";i:1;i:1;i:2;i:1;}i:2;i:1;}i:2;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:1;}i:2;i:1;}i:3;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1;}i:4;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:592:"Developers have been developing since computers first began. This means we have a history of common problems and have constructed solutions to these, shared them and over decades optimised them. This article will discuss common problems that you'll face when constructing your web application, and the best practices to deal with them. This article cannot possible cover all design patterns, and some problems require extracurricular study or outside expertise in computer science or mathematics to solve. In fact some problems are not actually computational problems but are people problems.";}i:2;i:38;}i:5;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:630;}i:6;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:630;}i:7;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:66:"Note that the term design patterns in programming often refers to ";}i:2;i:632;}i:8;a:3:{i:0;s:13:"interwikilink";i:1;a:4:{i:0;s:26:"wp>Software design pattern";i:1;s:83:"specific practices that have been given a name and have a large following in theory";i:2;s:2:"wp";i:3;s:23:"Software design pattern";}i:2;i:698;}i:9;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:157:". This article defines design patterns as more broad than that, it will cover practices that only come with experience and practices that come out of theory.";}i:2;i:812;}i:10;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:969;}i:11;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:969;}i:12;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:20:"Also check out this ";}i:2;i:971;}i:13;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:50:"http://www.mindmeister.com/7008138/design-patterns";i:1;s:57:"mindmap of different design patterns and their categories";}i:2;i:991;}i:14;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:":";}i:2;i:1103;}i:15;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1104;}i:16;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1104;}i:17;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:6:"iframe";i:1;a:7:{s:3:"url";s:102:"http://www.mindmeister.com/maps/public_map_shell/263325254/design-patterns?width=600&height=400&z=auto";s:5:"width";s:5:"427px";s:6:"height";s:5:"356px";s:3:"alt";N;s:6:"scroll";b:0;s:6:"border";b:0;s:5:"align";b:0;}i:2;i:5;i:3;s:140:"{{url>http://www.mindmeister.com/maps/public_map_shell/263325254/design-patterns?width=600&height=400&z=auto 427px,356px noscroll noborder}}";}i:2;i:1106;}i:18;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:1246;}i:19;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1247;}i:20;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:1247;}i:21;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:13:"PHP Standards";i:1;i:2;i:2;i:1247;}i:2;i:1247;}i:22;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:1247;}i:23;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1247;}i:24;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:325:"There are a million ways to skin a cat. Just because you can skin the cat in the way you currently prefer, doesn't mean you should. We follow standards to help collaboration, scalability and maintainability. Of course standards are not religion, you'll need to balance the effort against reward when complying with standards.";}i:2;i:1274;}i:25;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1599;}i:26;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1599;}i:27;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"For a long time ";}i:2;i:1601;}i:28;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:1617;}i:29;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:128:" didn't have any standards. That is why it can be written procedurally or object oriented and incorporate aspects of functional.";}i:2;i:1620;}i:30;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:1748;}i:31;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:1748;}i:32;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"However the ";}i:2;i:1750;}i:33;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:23:"http://www.php-fig.org/";i:1;s:12:"PHP FIG team";}i:2;i:1762;}i:34;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:51:" was constructed out of representatives from major ";}i:2;i:1802;}i:35;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:1853;}i:36;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:86:" frameworks. They came together to create standards for the framework development and ";}i:2;i:1856;}i:37;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:1942;}i:38;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:" in general. Their standards are called PSR (";}i:2;i:1945;}i:39;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:1990;}i:40;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:52:" Standard Recommendations). You can find all of the ";}i:2;i:1993;}i:41;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:61:"https://github.com/php-fig/fig-standards/tree/master/accepted";i:1;s:56:"accepted (voted in) standards on their Github repository";}i:2;i:2045;}i:42;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:2167;}i:43;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2168;}i:44;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2168;}i:45;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:93:"One important standard that isn't mentioned in the PSRs, is the docblock syntax. Comments in ";}i:2;i:2170;}i:46;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:2263;}i:47;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:60:" can be written via double forward slashes or a single hash.";}i:2;i:2266;}i:48;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:2326;}i:49;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:210:"
#this is a comment
//this is also a comment, most libraries use the // style because it looks nicer. Many languages use the // instead of the # so it keeps things consistent.
/*
This
is
a
multiline
comment
*/
";i:1;s:3:"php";i:2;N;}i:2;i:2333;}i:50;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:2333;}i:51;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:152:"This is useful for one liner comments. However sometimes we need to write larger comments to explain functions, methods and classes. You should use the ";}i:2;i:2557;}i:52;a:3:{i:0;s:13:"interwikilink";i:1;a:4:{i:0;s:9:"wp>PHPDoc";i:1;s:22:"PHPDoc docblock syntax";i:2;s:2:"wp";i:3;s:6:"PHPDoc";}i:2;i:2709;}i:53;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:337:". The syntax is also sometimes used by libraries which use meaningful commenting to inject code or other features into your coding. One example is dependency injection that is managed by docblock comments. However I am not a fan of this approach as I think this confuses people and comments should be comments, not meta programming code.";}i:2;i:2745;}i:54;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3083;}i:55;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:3083;}i:56;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:5:"PSR-0";i:1;i:3;i:2;i:3083;}i:2;i:3083;}i:57;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:3083;}i:58;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3083;}i:59;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:90:"The PSR-0 standard was their first standard and the most readily accepted standard by the ";}i:2;i:3100;}i:60;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:3190;}i:61;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:127:" community. This was for autoloading and structuring of sharable code libraries. We already went through the PSR-0 standard in ";}i:2;i:3193;}i:62;a:3:{i:0;s:12:"internallink";i:1;a:2:{i:0;s:49:"PHP - Server Side Architecture#composer_libraries";i:1;s:60:"the composer section in the server side architecture article";}i:2;i:3320;}i:63;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:". The ";}i:2;i:3434;}i:64;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:70:"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-0.md";i:1;s:43:"official documentation is located on Github";}i:2;i:3440;}i:65;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:3558;}i:66;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:3559;}i:67;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:3559;}i:68;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:522:"Not all of our libraries need to be PSR-0 based. Only those that we want shareable. Some libraries are actually a simple static class, and they will be autoloaded based on a class map and not namespacing. This is what was done with the CiTemplating library. The reason being is that if you use any of the static methods, you would need to call the namespace in every view file. This is usually not a problem in parser based templating libraries, because of their domain specific language. But this was straight and simple ";}i:2;i:3561;}i:69;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:4083;}i:70;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:4086;}i:71;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4087;}i:72;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4087;}i:73;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:235:"Codeigniter itself is not a PSR-0 framework, if it were, everything from controllers to models would require namespacing and autoloading. However newer frameworks are becoming fully PSR-0 based, if you're interested take a look at the ";}i:2;i:4089;}i:74;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:19:"http://laravel.com/";i:1;s:17:"Laravel framework";}i:2;i:4324;}i:75;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:80:". For now you won't need all those complexities so we'll stick with Codeigniter.";}i:2;i:4365;}i:76;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4445;}i:77;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4445;}i:78;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:177:"Remember since we're using CiAutoloading, we can put PSR-0 libraries into our own libraries directory or third_party directory, or we could use Composer to autoload them for us.";}i:2;i:4447;}i:79;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4625;}i:80;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:4625;}i:81;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:5:"PSR-1";i:1;i:3;i:2;i:4625;}i:2;i:4625;}i:82;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:4625;}i:83;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4625;}i:84;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:4642;}i:85;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:92:"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md";i:1;s:47:"PSR-1 standard is a basic coding style standard";}i:2;i:4646;}i:86;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:104:". You don't have to follow it to the letter, but doing so will help interoperability between developers.";}i:2;i:4790;}i:87;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:4894;}i:88;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:4894;}i:89;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:587:"Some of the important highlights is the practice of StudlyCaps for class names. It's also a good practice to follow StudlyCaps for folder directories holding classes, as this will keep things consistent for namespacing. Notice also that it also specifies that your class method names should be camelCased, but your variable names can be either underscored or camelCased. While this may be a good practice in library development, you don't need to follow this in your controller methods or models. Controller methods should behave RESTfully but also be readable since it's going into the ";}i:2;i:4896;}i:90;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"URL";}i:2;i:5483;}i:91;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:". Sharing underscore based URLs are always easier than having ambiguous camelCased or hyphen URLs.";}i:2;i:5486;}i:92;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5584;}i:93;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5584;}i:94;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:325:"Note that you not use underscores for your classnames when you're autoloading. The PSR-0 autoloader will think of underscores as directory separators. This will confuse you, so make sure to avoid that. Underscores in folder names won't affect it, but it's best to avoid and keep all class names or folder names as StudlyCaps.";}i:2;i:5586;}i:95;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:5912;}i:96;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:5912;}i:97;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:5:"PSR-2";i:1;i:3;i:2;i:5912;}i:2;i:5912;}i:98;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:5912;}i:99;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:5912;}i:100;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:5929;}i:101;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:89:"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md";i:1;s:47:"PSR-2 standard is a major coding style standard";}i:2;i:5933;}i:102;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:6074;}i:103;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6075;}i:104;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6075;}i:105;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:344:"This was the most controversial, mainly because developers nitpicked little things they didn't like. For example many developers prefer using tabs instead of 4 spaces, however this is often a non-issue, since many IDEs allow you to set the tabbing size and whether it gets replaced by spaces anyway. Notepad++ will allow you to do this through ";}i:2;i:6077;}i:106;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:6421;}i:107;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"setting";}i:2;i:6423;}i:108;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:6430;}i:109;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"preferences";}i:2;i:6432;}i:110;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:6443;}i:111;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:6445;}i:112;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6446;}i:113;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6446;}i:114;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:203:"However many of the standards guide is part of good developmental practice, so make sure you read it and understand why they put it as part of the standard. It's not just because they prefer it that way!";}i:2;i:6448;}i:115;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6651;}i:116;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6651;}i:117;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:114:"In the end it's up to you if you prefer to abide by the PSR-2. If you do you can proudly claim it in your library.";}i:2;i:6653;}i:118;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:6768;}i:119;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:6768;}i:120;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:5:"PSR-3";i:1;i:3;i:2;i:6768;}i:2;i:6768;}i:121;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:6768;}i:122;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:6768;}i:123;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:6785;}i:124;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:87:"https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-3-logger-interface.md";i:1;s:76:"PSR-3 standard is actually a guide for a common interface to logging classes";}i:2;i:6789;}i:125;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:91:". This means unless you're building a logging application you won't need to worry about it.";}i:2;i:6957;}i:126;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7048;}i:127;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7048;}i:128;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:462:"However having a common logging interface means you can dependency inject any logging class and expect it to work in similar ways due to the enforcement of the interface contract. This way your libraries can log errors or notices to the application, without knowing what kind of logging library the user is going to have in advance. If you are going to implement logging, make sure to wrap it in conditional logic in case the user has no logging class available.";}i:2;i:7050;}i:129;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7512;}i:130;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7512;}i:131;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"At any case, ";}i:2;i:7514;}i:132;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:62:"http://ellislab.com/codeigniter/user-guide/general/errors.html";i:1;s:27:"Codeigniter's logging class";}i:2;i:7527;}i:133;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:" is not compatible with PSR-3. So only use it for your non-shareable controllers and models. If you need a more robust library, use ";}i:2;i:7621;}i:134;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:34:"https://github.com/Seldaek/monolog";i:1;s:7:"Monolog";}i:2;i:7753;}i:135;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:" which is PSR-3 compliant.";}i:2;i:7799;}i:136;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:7826;}i:137;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:7826;}i:138;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"OOP Patterns";i:1;i:2;i:2;i:7826;}i:2;i:7826;}i:139;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:7826;}i:140;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:7826;}i:141;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"In the ";}i:2;i:7852;}i:142;a:3:{i:0;s:12:"internallink";i:1;a:2:{i:0;s:30:"PHP - Server Side Architecture";i:1;s:36:"PHP server side architecture section";}i:2;i:7859;}i:143;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:141:" we talked about the four principles of object oriented programming. This section is going to expand on that topic in a more practical sense.";}i:2;i:7930;}i:144;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8071;}i:145;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8073;}i:146;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"SOLID Principles";i:1;i:3;i:2;i:8073;}i:2;i:8073;}i:147;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:8073;}i:148;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8073;}i:149;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:8101;}i:150;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:73:"http://net.tutsplus.com/tutorials/how-to-write-code-that-embraces-change/";i:1;s:16:"SOLID principles";}i:2;i:8105;}i:151;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:197:" stand for Single responsibility, Open-closed, Liskov substitution, Interface segregation and Dependency inversion. These principles are intended to make your development maintainable and scalable.";}i:2;i:8199;}i:152;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8396;}i:153;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:8398;}i:154;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"Single Responsibility Principle";i:1;i:4;i:2;i:8398;}i:2;i:8398;}i:155;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:8398;}i:156;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8398;}i:157;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:171:"Each object should only have a single responsibility, and that entire responsibility should be encapsulated by that object. It's about making sure your object is cohesive.";}i:2;i:8439;}i:158;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:8610;}i:159;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:8610;}i:160;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:459:"A responsibility is defined as a reason to change. Classes should only have one reason to change. As an example, consider a class that compiles and prints a report. This could be changed for two reasons. First, the content of the report can change. Second, the format of the report can change. The single responsibility principle says that these two aspects of the problem are really two separate responsibilities, and should therefore be in separate classes.";}i:2;i:8612;}i:161;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9071;}i:162;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9071;}i:163;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:306:"By keeping your object cohesive, it means any edits or improvements you make to the code of a class will be focused on that single responsibility, hence lowering the chance of breaking the code for other responsibilities. This also isolates any problems making it easier to understand if you need to debug.";}i:2;i:9073;}i:164;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9379;}i:165;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9379;}i:166;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:206:"You may then argue how deep should problems be separated? After all, with a microscope, there's always more room to break things down. Well there's a famous computer science aphorism made by David Wheeler: ";}i:2;i:9381;}i:167;a:3:{i:0;s:13:"interwikilink";i:1;a:4:{i:0;s:14:"wp>Indirection";i:1;s:81:""All problems in computer science can be solved by another level of indirection."";i:2;s:2:"wp";i:3;s:11:"Indirection";}i:2;i:9587;}i:168;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:"  Which was then retorted by Kevlin Henney with ";}i:2;i:9687;}i:169;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:9735;}i:170;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:9736;}i:171;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:57:"except for the problem of too many layers of indirection.";}i:2;i:9739;}i:172;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:9796;}i:173;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:9797;}i:174;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:9799;}i:175;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"Open-Closed Principle";i:1;i:4;i:2;i:9799;}i:2;i:9799;}i:176;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:9799;}i:177;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:9799;}i:178;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:315:"Each object should be open to be extended, but closed for modification. Basically this refers to the fact that changes to the source code that isn't a bug fix often requires extra unit testing and code reviews because extra features may break existing compatibility. This is especially true for highly coupled code.";}i:2;i:9830;}i:179;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10145;}i:180;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10145;}i:181;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:127:"Therefore new features should be created through the extension of child classes, instead of modifying the existing source code.";}i:2;i:10147;}i:182;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10274;}i:183;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10274;}i:184;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:320:"However if you left this principle on such vague terms, then you'll eventually hit the problem of feature creep and messy structure. This is why the Open-Closed principle in practice actually refers to the usage of abstract interfaces, so that new features can be created as concrete objects that implement the abstract ";}i:2;i:10276;}i:185;a:3:{i:0;s:13:"emphasis_open";i:1;a:0:{}i:2;i:10596;}i:186;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"closed";}i:2;i:10598;}i:187;a:3:{i:0;s:14:"emphasis_close";i:1;a:0:{}i:2;i:10604;}i:188;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:121:" interface. This allows an easy swapping out of features as dependencies. Note that this could be done with abstracts in ";}i:2;i:10606;}i:189;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:10727;}i:190;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:160:" too. Normal classes could also be extended, but interfaces would the most suitable for this purpose, since interfaces shouldn't be changed much after creation.";}i:2;i:10730;}i:191;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10890;}i:192;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:10890;}i:193;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"Let's see an example:";}i:2;i:10892;}i:194;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:10913;}i:195;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1204:"
//here's out abstract interface
interface Vehicle{
    public function accelerate();
    public function stop();
}

//our first feature was just a Sedan
class Sedan implements Vehicle{
    public function accelerate(){
        echo 'Vroom!';
    }
    public function stop(){
        echo 'EHHH!';
    }
}

//later on we found out we needed Trucks too (this was modified, but the interface wasn't)
class Truck implements Vehicle{
    public function accelerate(){
        echo 'Brrrm!';
    }
    public function stop(){
        echo 'CHHH!';
    }
}

//now we can use the new feature that was openly extended from the interface
//but since the interface was closed, we didn't need any more code reviews, and we have a consistent "interface" to work with
class Drive(){
    //these dependencies are hard coupled, you normally shouldn't do this, use dependency injection instead
    public function buy_groceries(){
        $vehicle = new Sedan;
        $vehicle->accelerate();
        echo 'At Groceries!';
        $vehicle->stop();
    }
    public function deliver_groceries(){
        $vehicle = new Truck;
        $vehicle->accelerate();
        echo 'At Retail!';
        $vehicle->stop();
    }
}
";i:1;s:3:"php";i:2;N;}i:2;i:10920;}i:196;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:12138;}i:197;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:29:"Liskov Substitution Principle";i:1;i:4;i:2;i:12138;}i:2;i:12138;}i:198;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:12138;}i:199;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:12138;}i:200;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:355:"Any child class that inherits from a parent class or abstract or interface should not break the parent class's functionality if the child class gets substituted for the parent class. Code may be type hinting for the parent class or abstract interface, and if the child class gets substituted, they will expect similar functionality. Consider this example:";}i:2;i:12177;}i:201;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:12532;}i:202;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:1093:"
//here is the parent class
class Rectangle{
    protected width;
    protected height;
    public function set_height($y){
        $this->height = $y;
    }
    public function set_width($x){
        $this->width = $x;
    }
    public function area(){
        return $this->width * $this->height;
    }
}

//squares are rectangles in math, but we'll see in a moment this violates LSP
class Square extends Rectangle{
    //we're method overriding here!
    public function area(){
        return $this->width ^ 2;
    }
}

//now Square class can be substituted for Rectangle
class Geometry{
    public __construct(Rectangle $shape){
        $shape->set_width(100);
        $shape->set_height(50);
        echo $shape->area();
    }
}

//this works, it's using the parent class
$rectangle_geometry = new Geometry(new Rectangle);

//this works as well, because Square extends Rectangle, the type hint passes
//however the functionality as expected is broken due to the method overriding
//violates liskov substitution principle so this is bad code!
$square_geometry = new Geometry(new Square);
";i:1;s:3:"php";i:2;N;}i:2;i:12539;}i:203;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:13646;}i:204;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:31:"Interface Segregation principle";i:1;i:4;i:2;i:13646;}i:2;i:13646;}i:205;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:13646;}i:206;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:13646;}i:207;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:510:"No objects implementing interfaces should be forced to implement methods that have no relation to their responsibility. This basically means we should break down large interfaces into small and highly cohesive interfaces, so when we're implementing interfaces, objects won't need to define functions that have no use and are just there to satisfy the interface. If you find yourself doing this, you need to break your interfaces down into one super abstract interface and relatively concrete child interfaces! ";}i:2;i:13687;}i:208;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14197;}i:209;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14197;}i:210;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:155:"Also note that you can have child interfaces extending parent interfaces, and by implementing the child interface, you'll inherit the parent interface too.";}i:2;i:14199;}i:211;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14354;}i:212;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:14356;}i:213;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:30:"Dependency Inversion principle";i:1;i:4;i:2;i:14356;}i:2;i:14356;}i:214;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:14356;}i:215;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:14356;}i:216;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:462:"Conventional dependency relationships from high level classes to low level utility classes are inverted for the purpose of rendering high-level classes independent of the low-level classes implementation details. High-level classes should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend upon details. Details should depend upon abstractions. Both high and low-level objects must depend on the same abstraction.";}i:2;i:14396;}i:217;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:14858;}i:218;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:8:"imagebox";i:1;a:2:{i:0;i:1;i:1;a:11:{s:4:"type";s:13:"internalmedia";s:3:"src";s:79:":web_application_development:embrace-change-switch-ligh-reversed-dependency.png";s:5:"title";s:0:"";s:5:"align";s:5:"right";s:5:"width";s:3:"200";s:6:"height";N;s:5:"cache";s:5:"cache";s:7:"linking";s:7:"details";s:1:"w";s:3:"200";s:6:"detail";s:163:"/lib/exe/detail.php?id=web_application_development%3Aphp_-_design_patterns&amp;media=web_application_development:embrace-change-switch-ligh-reversed-dependency.png";s:5:"exist";b:1;}}i:2;i:1;i:3;s:88:"[{{ :web_application_development:embrace-change-switch-ligh-reversed-dependency.png?200|";}i:2;i:14860;}i:219;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:8:"imagebox";i:1;a:2:{i:0;i:3;i:1;s:54:"Dependency Inverted Switch with a Switchable Interface";}i:2;i:3;i:3;s:54:"Dependency Inverted Switch with a Switchable Interface";}i:2;i:14948;}i:220;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:8:"imagebox";i:1;a:2:{i:0;i:4;i:1;s:3:"}}]";}i:2;i:4;i:3;s:3:"}}]";}i:2;i:15002;}i:221;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15002;}i:222;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:458:"Basically instead of flowing from a concrete library depending on a concrete lower level library, the concrete library depends on an intermediate abstraction. This has been what we've been doing with interfaces. The high level class type hints at an interface to be injected, the low level class implements the interface. The interface is created as an abstract intermediary. All concrete classes thus depend on abstractions linking to more concrete classes.";}i:2;i:15007;}i:223;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15465;}i:224;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15465;}i:225;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:208:"This is the essence of dependency injection, so that way we can not only unit test our classes by passing in dependencies, but we can also have highly maintainable code so we can easily swap out dependencies.";}i:2;i:15467;}i:226;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:15676;}i:227;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:15676;}i:228;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"Method Manipulation";i:1;i:3;i:2;i:15676;}i:2;i:15676;}i:229;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:15676;}i:230;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:15676;}i:231;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:87:"Methods are the functional units to a class. Also note that when developers talk about ";}i:2;i:15707;}i:232;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:15794;}i:233;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"members";}i:2;i:15795;}i:234;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:15802;}i:235;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" or ";}i:2;i:15803;}i:236;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:15807;}i:237;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:"properties";}i:2;i:15808;}i:238;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:15818;}i:239;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:224:" of a class they usually mean the variables to the class, not the methods. It is recommended that developers use methods as the verbs in order to manipulate the state of a class, rather than directly accessing the variables.";}i:2;i:15819;}i:240;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16043;}i:241;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:16045;}i:242;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:25:"Constructor & Destructors";i:1;i:4;i:2;i:16045;}i:2;i:16045;}i:243;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:16045;}i:244;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16045;}i:245;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"Every class can have a ";}i:2;i:16080;}i:246;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:48:"http://php.net/manual/en/language.oop5.decon.php";i:1;s:26:"constructor and destructor";}i:2;i:16103;}i:247;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:16182;}i:248;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:52:"http://www.php.net/manual/en/language.oop5.magic.php";i:1;s:12:"magic method";}i:2;i:16183;}i:249;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:58:". All magic methods are prepended with double underscores.";}i:2;i:16252;}i:250;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16310;}i:251;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16310;}i:252;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:326:"The construct function is called whenever the object is instantiated. This is only relevant for instantiated objects, not static classes. This function is used to setup all the necessary dependencies and variables for the object to operate. Therefore we often pass in parameters to the method with type hints for dependencies.";}i:2;i:16312;}i:253;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:16638;}i:254;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:294:"
class SomeRandomClass{
    private $parameter;
    private $type_hinted_dependency;
    public function __construct($default_parameter, iInterface $type_hinted_dependency){
        $this->parameter = $default_parameter;
        $this->type_hinted_dependency = $type_hinted_dependency;
    }
}
";i:1;s:3:"php";i:2;N;}i:2;i:16645;}i:255;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:16645;}i:256;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:146:"When you're extending a class, you may need to call the parent constructor, as that will setup the parent's initialisation. You will need to call:";}i:2;i:16953;}i:257;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17099;}i:258;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:207:"
class ChildClass extends ParentClass{
    public function __construct(){
        //notice how we use the :: instead of the -> which means its calling it statically...
        parent::__construct();
    }
}
";i:1;s:3:"php";i:2;N;}i:2;i:17106;}i:259;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17106;}i:260;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:117:"Destructors are similar to constructors, but they are called either when the scripts finishes execution (in the case ";}i:2;i:17327;}i:261;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:17444;}i:262;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:52:" it finishes once the response is sent) or when the ";}i:2;i:17447;}i:263;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:73:"http://stackoverflow.com/questions/8798443/best-way-to-destroy-php-object";i:1;s:15:"object is unset";}i:2;i:17499;}i:264;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:17592;}i:265;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17593;}i:266;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17593;}i:267;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:33:"Destructors are somewhat rare in ";}i:2;i:17595;}i:268;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:17628;}i:269;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:351:" because of the automatic garbage collection of memory at the end of script execution. However you can use destructors to clean up connections, resources and do house cleaning operations like logging any cache to disk. If you find yourself calling an explicit command to do whenever you want to stop using an object, then you put it in the destructor.";}i:2;i:17631;}i:270;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:17982;}i:271;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:17982;}i:272;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:97:"Destructors will however need to be used for long running daemon processes to avoid memory leaks.";}i:2;i:17984;}i:273;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18081;}i:274;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:18083;}i:275;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:10:"Visibility";i:1;i:4;i:2;i:18083;}i:2;i:18083;}i:276;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:18083;}i:277;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18083;}i:278;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"The ";}i:2;i:18103;}i:279;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:57:"http://www.php.net/manual/en/language.oop5.visibility.php";i:1;s:20:"visibility modifiers";}i:2;i:18107;}i:280;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:635:" are there to enforce proper encapsulation coding style, but also are a hint of your intentions to other developers reading your code, thus making it easier to understand. Therefore it's best practice to always put a visibility modifier (even if your code works without them), and make sure they are contextually relevant. If they are public, they should be and will be accessed from outside the class. If they are protected, they should be and will be accessed from child classes. If they are private they should be and will not be accessed from classes other than the designated class. Refer to the official documentation for syntax.";}i:2;i:18189;}i:281;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:18824;}i:282;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:18824;}i:283;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:204:"Because we should be using verbs to modify state, methods are the ones that should be public, and class properties should be not accessible outside of methods. This however is a guideline, not a religion.";}i:2;i:18826;}i:284;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19030;}i:285;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:19032;}i:286;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"Method Overloading";i:1;i:4;i:2;i:19032;}i:2;i:19032;}i:287;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:19032;}i:288;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19032;}i:289;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:58:"http://www.php.net/manual/en/language.oop5.overloading.php";i:1;s:35:"PHP's interpretation of overloading";}i:2;i:19060;}i:290;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:" is different from other languages. This part refers to method overloading from the perspective of other languages.";}i:2;i:19158;}i:291;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19273;}i:292;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19273;}i:293;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:229:"Method overloading refers to the definition of multiple methods with the same name but different number of parameters. The goal is be able to call the same method with different parameters and execute different branches of logic.";}i:2;i:19275;}i:294;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19504;}i:295;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19504;}i:296;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:19506;}i:297;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:222:" doesn't need to do this because it has the capability of having default parameters in its argument list. This pretty much simulates the same functionality. All default parameters should be at the end of the argument list.";}i:2;i:19509;}i:298;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:19731;}i:299;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:454:"

//default parameters has to be after the required parameters or else there'll be a fatal error
function do_something(
    $required,
    &$reference, //this is pass by reference
    $optional = null,
    iInterface $object = null,
    $string = 'blah blah blah',
    $array = array('lol'),
    $boolean = false,
){
//default parameters are not the same as typehints, an empty variable will have the default type, but anything else could be passed in
}
";i:1;s:3:"php";i:2;N;}i:2;i:19738;}i:300;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:19738;}i:301;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:44:"Note that the passing by reference with the ";}i:2;i:20206;}i:302;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:20250;}i:303;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"&";}i:2;i:20252;}i:304;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:20253;}i:305;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:224:" prefixed. This means the value is references instead of copied. Normally when you pass in a variable to a function, it copies the value and then does work on it. It doesn't affect the original variable. However you can use ";}i:2;i:20255;}i:306;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:20479;}i:307;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:"&";}i:2;i:20481;}i:308;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:20482;}i:309;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:419:" to make sure that any changes to that variable that happens inside the function also gets changed outside of the function, this is because the value is now a reference to the original value. This often gets used when we want a function to have multiple side effects, so that it's not only returning a final output, but also modifying things around it. This is more frequently used when manipulating arrays through the ";}i:2;i:20484;}i:310;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:20903;}i:311;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"foreach";}i:2;i:20905;}i:312;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:20912;}i:313;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:233:" function. We can use it to change the array's values as we iterate through it, instead of returning a finished value and then replacing the old array with the new array. Other than that, you should keep your references to a minimum.";}i:2;i:20914;}i:314;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21147;}i:315;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21147;}i:316;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:47:"One more thing to note is default parameter of ";}i:2;i:21149;}i:317;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:21196;}i:318;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"null";}i:2;i:21198;}i:319;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:21202;}i:320;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:95:". When we type hint an object to be passed in and at the same time have a default parameter of ";}i:2;i:21204;}i:321;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:21299;}i:322;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"null";}i:2;i:21301;}i:323;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:21305;}i:324;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:", this means we can pass in ";}i:2;i:21307;}i:325;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:21335;}i:326;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"null";}i:2;i:21337;}i:327;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:21341;}i:328;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:299:" as the parameter when calling the function. This allows us to bypass the need to pass in an object. This can be useful when you need to conditionally branch logic depending on the existence of an object, but you don't want to force your user to need to have an object that implements the interface.";}i:2;i:21343;}i:329;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21642;}i:330;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21642;}i:331;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:61:"If you need to have variable number of parameters, try using ";}i:2;i:21644;}i:332;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:55:"http://www.php.net/manual/en/function.func-get-args.php";i:1;s:13:"func_get_args";}i:2;i:21705;}i:333;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:21778;}i:334;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21779;}i:335;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:21781;}i:336;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:15:"Method Chaining";i:1;i:4;i:2;i:21781;}i:2;i:21781;}i:337;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:21781;}i:338;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21781;}i:339;a:3:{i:0;s:13:"interwikilink";i:1;a:4:{i:0;s:18:"wp>Method chaining";i:1;s:15:"Method chaining";i:2;s:2:"wp";i:3;s:15:"Method chaining";}i:2;i:21806;}i:340;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:98:" the practice of calling multiple methods one after the other in a very succinct way. For example:";}i:2;i:21844;}i:341;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:21942;}i:342;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:70:"
$result = $object->place('dog')->with('cat')->and('tree')->result();
";i:1;s:3:"php";i:2;N;}i:2;i:21949;}i:343;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:21949;}i:344;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:194:"Method chaining may potentially reduce the number of code written and improve readability. However too many method chains will result in a train wreck where it becomes difficult to isolate bugs.";}i:2;i:22033;}i:345;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22227;}i:346;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22227;}i:347;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:"The key to implementation is to have an object with a number mutator methods that return ";}i:2;i:22229;}i:348;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:22318;}i:349;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"$this";}i:2;i:22320;}i:350;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:22325;}i:351;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:22327;}i:352;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22328;}i:353;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22328;}i:354;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"For example:";}i:2;i:22330;}i:355;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22342;}i:356;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:406:"
class FakeString{
    private $str;
    function __construct(){
        $this->str = "";
    }
    //mutator methods mutate a variable
    function addA(){
        $this->str .= "a";
        return $this;
    }
    function addB(){
        $this->str .= "b";
        return $this;
    }
    function getStr(){
        return $this->str;
    }
}

$a = new fakeString();

echo $a->addA()->addB()->getStr();
";i:1;s:3:"php";i:2;N;}i:2;i:22349;}i:357;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22349;}i:358;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:"You'll see method chaining when using Codeigniter's Active Records class.";}i:2;i:22769;}i:359;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:22842;}i:360;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:22844;}i:361;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:17:"Method Overriding";i:1;i:4;i:2;i:22844;}i:2;i:22844;}i:362;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:22844;}i:363;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:22844;}i:364;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:537:"Method overriding simply refers to child classes that override a method from their parent class. This method would have to have the same name to override. You would do this every time you need to reuse the parent class's functionality but need one thing changed. Of course be careful not to violate the Liskov Substitution Principle. Sometimes you should create a completely new class, or use an interface instead. You'll use this technique often with Codeigniter since it allows all of its native classes to be extended and overwritten.";}i:2;i:22871;}i:365;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23408;}i:366;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23408;}i:367;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"You can also use the ";}i:2;i:23410;}i:368;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:23431;}i:369;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"final";}i:2;i:23433;}i:370;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:23438;}i:371;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:111:" keyword to prevent overriding. This simply means the method the final form and should not be overwritten. The ";}i:2;i:23440;}i:372;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:23551;}i:373;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"final";}i:2;i:23553;}i:374;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:23558;}i:375;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:89:" keyword can be used on the class itself to prevent overwriting, or just a single method.";}i:2;i:23560;}i:376;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23649;}i:377;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:168:"
class BaseClass {
   //finalised method
   final public function do_something() {}
}

//finalised class
final class NoChildren{
   public function do_something() {}
}
";i:1;s:3:"php";i:2;N;}i:2;i:23656;}i:378;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:23838;}i:379;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:6:"Traits";i:1;i:4;i:2;i:23838;}i:2;i:23838;}i:380;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:23838;}i:381;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23838;}i:382;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:81:"Remember how child classes cannot extend multiple parent classes? Well there's a ";}i:2;i:23854;}i:383;a:3:{i:0;s:13:"interwikilink";i:1;a:4:{i:0;s:43:"wp>Multiple inheritance#The_diamond_problem";i:1;s:15:"reason for that";i:2;s:2:"wp";i:3;s:40:"Multiple inheritance#The_diamond_problem";}i:2;i:23935;}i:384;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:23998;}i:385;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:23999;}i:386;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:23999;}i:387;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:94:"Instead programming languages have designed mixins to be alternatives to multiple extensions. ";}i:2;i:24001;}i:388;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:24095;}i:389;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:" calls them ";}i:2;i:24098;}i:390;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:45:"http://phpmaster.com/using-traits-in-php-5-4/";i:1;s:8:""traits"";}i:2;i:24110;}i:391;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:". These are only available on ";}i:2;i:24168;}i:392;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"PHP";}i:2;i:24198;}i:393;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:164:" 5.4. However don't use traits too much, you'll start to violate OOP principles because of how easy it seems at first, but eventually run into maintenance problems.";}i:2;i:24201;}i:394;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24366;}i:395;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:24366;}i:396;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:21:"Dependency Management";i:1;i:3;i:2;i:24366;}i:2;i:24366;}i:397;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:3;}i:2;i:24366;}i:398;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24366;}i:399;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:192:"Managing dependencies is a core activity to developing in an object orientated manner. Simply put it's how you structure your object loading system because all objects depend on other objects.";}i:2;i:24399;}i:400;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:24591;}i:401;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:24591;}i:402;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:69:"Codeigniter by default uses a custom loader in which you simply call ";}i:2;i:24593;}i:403;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:24662;}i:404;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"$this";}i:2;i:24664;}i:405;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:24669;}i:406;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"load()";}i:2;i:24671;}i:407;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:24677;}i:408;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:973:". This is useful for Codeigniter's system libraries, but eventually becomes unmaintainable and untestable. It's unmaintainable because all the dependencies are hard coded into the objects themselves. So if you ever need to change the dependencies to another object, you'll have to find each line of code in which you load that dependency and change the name to another dependency. This becomes very difficult when you project is large and the dependency you're loading is commonly shared. It's untestable because each unit of code cannot be isolated, their dependencies cannot be mocked. This is necessary in test driven development because we isolate each class and test their functions, if the class is dependent on other classes, then we'll need to mock those dependencies, essentially creating a dummy class that acts like the dependent class but doesn't do anything permanent. By hardcoding the dependencies into the code, it becomes impossible to provide those mocks.";}i:2;i:24679;}i:409;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:25652;}i:410;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:25652;}i:411;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:391:"So eventually we arrive at a practice called dependency injection. Instead of hardcoding the dependencies into our classes, we establish dependent parameters to the class and inject those during run time. There are two ways to do this, through constructor injection or setter injection. This example shows these two methods. Polycademy recommends you to use the constructor injection method.";}i:2;i:25654;}i:412;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:26045;}i:413;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:953:"
//constructor injection (use it for long lived dependencies that will be persistent)
class RandomClass{
    private $dependent_class;
    //it's best practice to set up interfaces or abstract typehints as this will make sure the dependencies are actually the ones we need and so we don't pass the wrong dependencies
    //we have here default null, which means we allow the user to pass null and bypass the dependency so we can do a setter injection instead
    public function __construct(iInterface $object = null){
        $this->dependent_class = $object;
    }
    
    //setter injection (use it for dependencies that change often, like dependencies that you don't know about until runtime)
    public set_dependency(iInterface $object){
        $this->dependent_class = $object;
    }
}

//using the constructor
$class = new RandomClass(new OtherClass);
//using the setter
$class = new RandomClass(null);
$class->set_dependency(new OtherClass);
";i:1;s:3:"php";i:2;N;}i:2;i:26052;}i:414;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:26052;}i:415;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:148:"Dependency injection becomes far more useful when we combine it with autoloading, that way we can simply specify the class name and not worry about ";}i:2;i:27019;}i:416;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:27167;}i:417;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"require";}i:2;i:27169;}i:418;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:27176;}i:419;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" or ";}i:2;i:27178;}i:420;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:27182;}i:421;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"include";}i:2;i:27184;}i:422;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:27191;}i:423;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:285:" functions to actually load the dependent classes into context. However because Codeigniter is not a PSR-0 compliant framework, it doesn't have a built in autoloader, so this kind of dependent injection may not work well with Codeigniter's system libraries. That's why we'll still use ";}i:2;i:27193;}i:424;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:27478;}i:425;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:"$this";}i:2;i:27480;}i:426;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:27485;}i:427;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"load";}i:2;i:27487;}i:428;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:27491;}i:429;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:227:" in our models and controllers. However there may be a possibility to keep hardcoded dependencies out of our models, and use our controllers to not only load all dependencies but then inject them all into the model constructor.";}i:2;i:27493;}i:430;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:27720;}i:431;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:27722;}i:432;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Inversion of Control";i:1;i:4;i:2;i:27722;}i:2;i:27722;}i:433;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:4;}i:2;i:27722;}i:434;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:27722;}i:435;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:414:"Once we have our dependency injection and autoloading setup, we can actually take a step further by completely abstracting our dependency management, so that all dependencies get managed in one place. We're still using constructor and setter injection, it's just we're no longer setting up all the dependencies in every place we're calling the necessary libraries, we're abstracting it to a single place called an ";}i:2;i:27752;}i:436;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:28166;}i:437;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"Inversion of Control Container";}i:2;i:28167;}i:438;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:28197;}i:439;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:132:" (IoC). You should all of the below information before using this technique, but for future reference just go to Polycademy's CiIoC:";}i:2;i:28198;}i:440;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:28331;}i:441;a:3:{i:0;s:10:"listu_open";i:1;a:0:{}i:2;i:28331;}i:442;a:3:{i:0;s:13:"listitem_open";i:1;a:1:{i:0;i:1;}i:2;i:28331;}i:443;a:3:{i:0;s:16:"listcontent_open";i:1;a:0:{}i:2;i:28331;}i:444;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:28335;}i:445;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:35:"https://github.com/Polycademy/CiIoC";i:1;s:5:"CiIoC";}i:2;i:28336;}i:446;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:62:" - Inversion of Control Container using Pimple for Codeigniter";}i:2;i:28381;}i:447;a:3:{i:0;s:17:"listcontent_close";i:1;a:0:{}i:2;i:28443;}i:448;a:3:{i:0;s:14:"listitem_close";i:1;a:0:{}i:2;i:28443;}i:449;a:3:{i:0;s:11:"listu_close";i:1;a:0:{}i:2;i:28443;}i:450;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:28443;}i:451;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:123:"We only really start doing this when the our dependency requirements starts getting very complex. This is often called the ";}i:2;i:28445;}i:452;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:28568;}i:453;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"object graph";}i:2;i:28569;}i:454;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:28581;}i:455;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:155:". If a particular class in a library requires 5 to 6 dependent constructor injected classes, every time we need this class, we'd have to repeat the 5 to 6 ";}i:2;i:28582;}i:456;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:28737;}i:457;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:14:"new ClassName;";}i:2;i:28739;}i:458;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:28753;}i:459;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:75:" initialisations every time we wanted to use that class. This violates the ";}i:2;i:28755;}i:460;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:28830;}i:461;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"Don't Repeat Yourself";}i:2;i:28831;}i:462;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:28852;}i:463;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:133:" (DRY) principle in software development. However this shouldn't be used for all classes, it should only be used for often shared or ";}i:2;i:28853;}i:464;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:28986;}i:465;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"global";}i:2;i:28987;}i:466;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:28993;}i:467;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:400:" libraries. So it shouldn't be used for our controllers or models. It actually can't because the Codeigniter framework wasn't built to do this. Some newer development frameworks such as Laravel is actually completely built from an IoC, so their controllers and models can managed from an IoC. However this isn't always necessary because putting everything into IoC can result in too much abstraction.";}i:2;i:28994;}i:468;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:29394;}i:469;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:29394;}i:470;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:897:"Now IoC containers can be thought of as HR manager who recruits all the necessary works and brings them together to work, instead of having each individual worker find their dependent workers. Now let's take this principle to the extreme, if our workers with dependencies are leaving the recruitment of their dependent workers to a manager, then shouldn't all managers pass their dependency management work to their managers? At some point, the CEO will be the one left with all the work. In the context of web applications, this would be the front controller. Now we don't want to pollute our front controller with all of this dependency work, this is because the front controller (CEO) should be bootstrapping everything, and HR management is only one thing a CEO (front controller) should be doing. At any case, the front controller will outsource the dependency management to an IoC container.";}i:2;i:29396;}i:471;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:30293;}i:472;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:30293;}i:473;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:49:"IoC is also often called the Hollywood principle ";}i:2;i:30295;}i:474;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:30344;}i:475;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:29:"Don't call us, we'll call you";}i:2;i:30345;}i:476;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:30374;}i:477;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:296:". Your dependent objects should not be calling the container to setup their dependencies. If you were to call the container to setup the dependencies while you were in the scope of your dependencies then you're not actually using inversion of control, you're using a different pattern called the ";}i:2;i:30375;}i:478;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:49:"http://blog.astrumfutura.com/tag/service-locator/";i:1;s:15:"Service Locator";}i:2;i:30671;}i:479;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:262:". This is an anti-pattern because you're trading hard coded object dependencies to a hard coded service locator dependency. Consider what would happen if you shared your library and the user did not have your kind of service locator, then the code wouldn't work.";}i:2;i:30740;}i:480;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:31002;}i:481;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:31002;}i:482;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:258:"Therefore in order to truly have your control inverted, you don't change the way you write your classes or libraries, they should be agnostic to any IoC containers, that means the code can still work even if you didn't have an inversion of control container.";}i:2;i:31004;}i:483;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:31262;}i:484;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:31262;}i:485;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:459:"Okay, so we've established that there will be an IoC container that will be either in the front controller, or somewhere really close the front controller. We've also established, that the IoC in the context of using Codeigniter will only be managing libraries, models or controllers. The next thing we have to establish is where we're going to actually going to call the IoC containers so it will manage all of our dependencies. Well this part is called the ";}i:2;i:31264;}i:486;a:3:{i:0;s:18:"doublequoteopening";i:1;a:0:{}i:2;i:31723;}i:487;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"Composition Root";}i:2;i:31724;}i:488;a:3:{i:0;s:18:"doublequoteclosing";i:1;a:0:{}i:2;i:31740;}i:489;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:234:". For our purposes, we're going to use the page controllers or page models as our composition root, so that's where the container will be called when we need to wire up many dependencies. Now let's get onto actually implementing this.";}i:2;i:31741;}i:490;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:31975;}i:491;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:31975;}i:492;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:110:"Firstly we need an IoC container. We could write up our own IoC container, and this has been explained in the ";}i:2;i:31977;}i:493;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:63:"http://net.tutsplus.com/tutorials/php/dependency-injection-huh/";i:1;s:40:"Dependency Injection tutorial in Nettuts";}i:2;i:32087;}i:494;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:108:". But we shouldn't be reinventing the wheel, so let's bring in a third party library to the containing. The ";}i:2;i:32195;}i:495;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:29:"http://pimple.sensiolabs.org/";i:1;s:17:"Pimple DI library";}i:2;i:32303;}i:496;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:" will be out IoC container.";}i:2;i:32354;}i:497;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32381;}i:498;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32381;}i:499;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:67:"First install it through Composer. It should be autoloaded through ";}i:2;i:32383;}i:500;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:43:"https://github.com/Polycademy/CiAutoloading";i:1;s:13:"CiAutoloading";}i:2;i:32450;}i:501;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:" and you'll be able to access Pimple anywhere in your application by simply calling ";}i:2;i:32511;}i:502;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:32595;}i:503;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"new Pimple();";}i:2;i:32597;}i:504;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:32610;}i:505;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:32612;}i:506;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:32613;}i:507;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:22:"
"pimple/pimple": "*"
";i:1;N;i:2;N;}i:2;i:32620;}i:508;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:32620;}i:509;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:206:"Now we need to setup the dependency object graph somewhere near the front controller. We could do it in the front controller, but since we hooked up composer as a pre-system hook, we should be doing in the ";}i:2;i:32652;}i:510;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:32858;}i:511;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"application/config";}i:2;i:32860;}i:512;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:32878;}i:513;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:59:" files. This makes more semantic sense. So let's create an ";}i:2;i:32880;}i:514;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:32939;}i:515;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"ioc.php";}i:2;i:32941;}i:516;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:32948;}i:517;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:25:" config file place it in ";}i:2;i:32950;}i:518;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:32975;}i:519;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"application/config";}i:2;i:32977;}i:520;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:32995;}i:521;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:71:". But before that we need to make sure this file gets autoloaded using ";}i:2;i:32997;}i:522;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:66:"http://ellislab.com/codeigniter/user-guide/general/autoloader.html";i:1;s:31:"Codeigniter's config autoloader";}i:2;i:33068;}i:523;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:". So go into the autoloader and add ";}i:2;i:33170;}i:524;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:33206;}i:525;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"ioc.php";}i:2;i:33208;}i:526;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:33215;}i:527;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:" into:";}i:2;i:33217;}i:528;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:33223;}i:529;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:37:"
$autoload['config'] = array('ioc');
";i:1;s:3:"php";i:2;N;}i:2;i:33230;}i:530;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:33230;}i:531;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:72:"In terms of the Codeigniter stack, the autoloader will be called in the ";}i:2;i:33281;}i:532;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:64:"http://ellislab.com/codeigniter/user-guide/libraries/loader.html";i:1;s:19:"native Loader class";}i:2;i:33353;}i:533;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:115:". This is called in the constructor of the native Controller class, which is just before the initialisation of the ";}i:2;i:33441;}i:534;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:67:"http://ellislab.com/codeigniter/user-guide/general/controllers.html";i:1;s:16:"page controllers";}i:2;i:33556;}i:535;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" in your ";}i:2;i:33644;}i:536;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:33653;}i:537;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"application/controllers";}i:2;i:33655;}i:538;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:33678;}i:539;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:50:" directory. You can find all those classes in the ";}i:2;i:33680;}i:540;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:33730;}i:541;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"system/core";}i:2;i:33732;}i:542;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:33743;}i:543;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" directory.";}i:2;i:33745;}i:544;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:33756;}i:545;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:33756;}i:546;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:"Now we're going to create the ";}i:2;i:33758;}i:547;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:33788;}i:548;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"ioc.php";}i:2;i:33790;}i:549;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:33797;}i:550;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:241:" container config file, and we're going to wire up our first library that will be initialised via a container. We're going assume that the libraries are already created right now, and create those libraries straight afterwards. Refer to the ";}i:2;i:33799;}i:551;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:32:"https://github.com/fabpot/Pimple";i:1;s:20:"Pimple documentation";}i:2;i:34040;}i:552;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:10:" and this ";}i:2;i:34097;}i:553;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:54:"http://phpmaster.com/dependency-injection-with-pimple/";i:1;s:19:"PHP Master tutorial";}i:2;i:34107;}i:554;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:39:" to see the syntax required for Pimple.";}i:2;i:34185;}i:555;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:34224;}i:556;a:3:{i:0;s:4:"file";i:1;a:3:{i:0;s:1423:"
<?php

//Pimple uses anonymous functions (lambdas) so it can "lazy load" the classes
//the functions will not be processed when the PHP interpreter goes through this file
//they will be kept inside the function waiting to be called as part of the container array
//once you call the functions, then the objects will be created! Thus "lazy loading", not "eager loading". Saves memory too!
//note Pimple is an object that acts like an array, see the actual Pimple code to see how this works

$ioc = new Pimple;

//this creates the Worker Library, not necessary since the WorkerLibrary has no dependencies, but demonstrates self-reference of $c
//when Pimple runs your anonymous function, it will pass in the Pimple object into $c making it self-referential, kind of like using $this
$ioc['WorkerLibrary'] = function($c){
    //no mention of $c, so we're not using it, but Pimple will pass it in regardless, so we need to accept
    return new WorkerLibrary;
};

//this creates the MasterLibrary and uses the self-referential $c to call upon WorkerLibrary and pass it as a dependency to MasterLibrary
$ioc['MasterLibrary'] = function($c){
    return new MasterLibrary($c['WorkerLibrary']);
};

//Pimple can also create random parameters...
$ioc['randomparameter'] = 'This is some random parameter';

//we need to pass the $ioc into the global $config variable, so now it can be accessed by Codeigniter
$config['ioc'] = $ioc;
";i:1;s:3:"php";i:2;s:7:"ioc.php";}i:2;i:34231;}i:557;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:34231;}i:558;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"Now we have to create the ";}i:2;i:35676;}i:559;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:35702;}i:560;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"MasterLibrary.php";}i:2;i:35704;}i:561;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:35721;}i:562;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:5:" and ";}i:2;i:35723;}i:563;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:35728;}i:564;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:17:"WorkerLibrary.php";}i:2;i:35730;}i:565;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:35747;}i:566;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:". They can be just some random class, it does not matter. Just make sure ";}i:2;i:35749;}i:567;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:35822;}i:568;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"MasterLibrary";}i:2;i:35824;}i:569;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:35837;}i:570;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" actually accepts ";}i:2;i:35839;}i:571;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:35857;}i:572;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:13:"WorkerLibrary";}i:2;i:35859;}i:573;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:35872;}i:574;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:70:" as a constructor injected dependency. Take note of how we placed the ";}i:2;i:35874;}i:575;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:35944;}i:576;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:"$ioc";}i:2;i:35946;}i:577;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:35950;}i:578;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:22:" back into the global ";}i:2;i:35952;}i:579;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:35974;}i:580;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"$config";}i:2;i:35976;}i:581;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:35983;}i:582;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:45:" value. This way it can be accessed from the ";}i:2;i:35985;}i:583;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:64:"http://ellislab.com/codeigniter/user-guide/libraries/config.html";i:1;s:27:"Config class in Codeigniter";}i:2;i:36030;}i:584;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:36126;}i:585;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36127;}i:586;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36127;}i:587;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:46:"In our page controller, we can just call this:";}i:2;i:36129;}i:588;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36175;}i:589;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:391:"
    //imagine this was a method of any controller
    public function test_ioc(){
        
        //this line can actually be placed in either the constructor, or a custom MY_Controller so you don't have to keep referring to the $config value.
        $ioc = $this->config->item('ioc');
		
        $masterlibrary = $ioc['MasterLibrary'];
		
        $masterlibrary->do_something();
	
    }
";i:1;s:3:"php";i:2;N;}i:2;i:36182;}i:590;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:36182;}i:591;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:92:"The two libraries of MasterLibrary and WorkerLibrary were just simple classes placed in the ";}i:2;i:36587;}i:592;a:3:{i:0;s:14:"monospace_open";i:1;a:0:{}i:2;i:36679;}i:593;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:21:"application/libraries";}i:2;i:36681;}i:594;a:3:{i:0;s:15:"monospace_close";i:1;a:0:{}i:2;i:36702;}i:595;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:73:" directory. These were of course autoloaded from the PSR-0 autoloader in ";}i:2;i:36704;}i:596;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:43:"https://github.com/Polycademy/CiAutoloading";i:1;s:13:"CiAutoloading";}i:2;i:36777;}i:597;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:".";}i:2;i:36838;}i:598;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:36839;}i:599;a:3:{i:0;s:4:"file";i:1;a:3:{i:0;s:283:"
<?php

class MasterLibrary{

	private $dependent;
	
	//this MasterLibrary needs a WorkerLibrary
	public function __construct($object){
	
		$this->dependent = $object;
	
	}
	
	//call this to do something
	public function do_something(){
	
		$this->dependent->do_something();
	
	}

}
";i:1;s:3:"php";i:2;s:17:"MasterLibrary.php";}i:2;i:36846;}i:600;a:3:{i:0;s:4:"file";i:1;a:3:{i:0;s:109:"
<?php

class WorkerLibrary{
	
	public function do_something(){
	
		echo 'The Worker Did Something';
	
	}

}
";i:1;s:3:"php";i:2;s:17:"WorkerLibrary.php";}i:2;i:37166;}i:601;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37166;}i:602;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:213:"There we go, you have not only created classes which is based on dependency injection, but they are also IoC agnostic. I could still call these classes normally if had to, but we've abstracted to an IoC container.";}i:2;i:37307;}i:603;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37520;}i:604;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37520;}i:605;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:247:"This is only one method of IoC containers, there are other ones too, but this is most simplistic! Remember don't bother using this with your controllers or models, just libraries and third party packages. Also refer to the Pimple documentation on ";}i:2;i:37522;}i:606;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:57:"https://github.com/fabpot/Pimple#defining-shared-services";i:1;s:15:"shared services";}i:2;i:37769;}i:607;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" or ";}i:2;i:37846;}i:608;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:66:"https://github.com/fabpot/Pimple#modifying-services-after-creation";i:1;s:9:"extension";}i:2;i:37850;}i:609;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:30:" for advanced usage of Pimple!";}i:2;i:37930;}i:610;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:37960;}i:611;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:37960;}i:612;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:"Check out Fabien's sliders on Dependency Injection, the guy who created Pimple:";}i:2;i:37962;}i:613;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38041;}i:614;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38041;}i:615;a:3:{i:0;s:6:"plugin";i:1;a:4:{i:0;s:6:"iframe";i:1;a:7:{s:3:"url";s:54:"http://www.slideshare.net/slideshow/embed_code/3028051";s:5:"width";s:5:"427px";s:6:"height";s:5:"356px";s:3:"alt";N;s:6:"scroll";b:0;s:6:"border";b:0;s:5:"align";b:0;}i:2;i:5;i:3;s:92:"{{url>http://www.slideshare.net/slideshow/embed_code/3028051 427px,356px noscroll noborder}}";}i:2;i:38043;}i:616;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:38135;}i:617;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38136;}i:618;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:38136;}i:619;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"Functional Programming";i:1;i:2;i:2;i:38136;}i:2;i:38136;}i:620;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:38136;}i:621;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38136;}i:622;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:19:"Anonymous functions";}i:2;i:38172;}i:623;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38191;}i:624;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38191;}i:625;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:"Closures (early binding + late binding via references)";}i:2;i:38193;}i:626;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38247;}i:627;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38247;}i:628;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:37:"Function currying returning functions";}i:2;i:38249;}i:629;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38286;}i:630;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38286;}i:631;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:90:"http://jburrows.wordpress.com/2011/06/24/the-state-of-functional-programming-in-php-5-3-x/";i:1;N;}i:2;i:38288;}i:632;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38378;}i:633;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:148:"
$closureWithArgs = function ($arg1, $arg2) {
    // body
};

$closureWithArgsAndVars = function ($arg1, $arg2) use ($var1, $var2) {
    // body
};
";i:1;N;i:2;N;}i:2;i:38385;}i:634;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:38542;}i:635;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:24:"Exception/Error Handling";i:1;i:2;i:2;i:38542;}i:2;i:38542;}i:636;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:38542;}i:637;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38542;}i:638;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"Custom Exceptions:";}i:2;i:38580;}i:639;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38598;}i:640;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:129:"
try {
    // try body
} catch (FirstExceptionType $e) {
    // catch body
} catch (OtherExceptionType $e) {
    // catch body
}
";i:1;N;i:2;N;}i:2;i:38605;}i:641;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38605;}i:642;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:24:"Conditional declaration:";}i:2;i:38744;}i:643;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:38768;}i:644;a:3:{i:0;s:4:"code";i:1;a:3:{i:0;s:141:"
// conditional declaration is *not* a side effect
if (! function_exists('bar')) {
    function bar()
    {
        // function body
    }
}
";i:1;N;i:2;N;}i:2;i:38775;}i:645;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:38775;}i:646;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:55:"What's the difference between throwing an error or try ";}i:2;i:38926;}i:647;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:38981;}i:648;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:79:" catch, vs if else. Exceptions are real exceptions. If/else is branching logic.";}i:2;i:38983;}i:649;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39063;}i:650;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:39063;}i:651;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:22:"Communication Patterns";i:1;i:2;i:2;i:39063;}i:2;i:39063;}i:652;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:39063;}i:653;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39063;}i:654;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"Pub/sub";}i:2;i:39099;}i:655;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39106;}i:656;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39106;}i:657;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:"Socket Programming";}i:2;i:39108;}i:658;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39126;}i:659;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39126;}i:660;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:53:"Event driven programming, event emitting and dispatch";}i:2;i:39128;}i:661;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39181;}i:662;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39181;}i:663;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:36:"Using CURL and web scraping (Goutte)";}i:2;i:39183;}i:664;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39219;}i:665;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:39221;}i:666;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:12:"Input/Output";i:1;i:2;i:2;i:39221;}i:2;i:39221;}i:667;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:39221;}i:668;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39221;}i:669;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:12:"Teach binary";}i:2;i:39247;}i:670;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39259;}i:671;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39259;}i:672;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:28:"File manipulation operations";}i:2;i:39261;}i:673;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39289;}i:674;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39289;}i:675;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Non blocking IO";}i:2;i:39291;}i:676;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39306;}i:677;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39306;}i:678;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"Asynchronous programming (";}i:2;i:39308;}i:679;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:45:"http://en.wikipedia.org/wiki/Asynchronous_I/O";i:1;N;}i:2;i:39334;}i:680;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:")";}i:2;i:39379;}i:681;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39380;}i:682;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39380;}i:683;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:"Compression";}i:2;i:39382;}i:684;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39393;}i:685;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39393;}i:686;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:54:"File streaming by binary chunks (due to memory limits)";}i:2;i:39395;}i:687;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39449;}i:688;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39449;}i:689;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:97:"Also mention Amazon S3 for file storage CDNs (most hosts dont allow to be a file hosting service)";}i:2;i:39451;}i:690;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39549;}i:691;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:39549;}i:692;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:16:"Shell Operations";i:1;i:2;i:2;i:39549;}i:2;i:39549;}i:693;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:39549;}i:694;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39549;}i:695;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"Proc open";}i:2;i:39579;}i:696;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39588;}i:697;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39588;}i:698;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:15:"Process forking";}i:2;i:39590;}i:699;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39605;}i:700;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39605;}i:701;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"Shell commands and passthru";}i:2;i:39607;}i:702;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39634;}i:703;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:39636;}i:704;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:18:"Parsing Operations";i:1;i:2;i:2;i:39636;}i:2;i:39636;}i:705;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:39636;}i:706;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39636;}i:707;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:48:"Regular expressions (for extracting information)";}i:2;i:39668;}i:708;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39716;}i:709;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39716;}i:710;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"HTML";}i:2;i:39718;}i:711;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:" Parsing ";}i:2;i:39722;}i:712;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:39731;}i:713;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:38:" Query Path (for extracting structure)";}i:2;i:39733;}i:714;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39771;}i:715;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39771;}i:716;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:4:"HTML";}i:2;i:39773;}i:717;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:11:" filtering ";}i:2;i:39777;}i:718;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:2:"->";}i:2;i:39788;}i:719;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:1:" ";}i:2;i:39790;}i:720;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:24:"http://htmlpurifier.org/";i:1;N;}i:2;i:39791;}i:721;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39815;}i:722;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39815;}i:723;a:3:{i:0;s:7:"acronym";i:1;a:1:{i:0;s:3:"XML";}i:2;i:39817;}i:724;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:18:" library and Xpath";}i:2;i:39820;}i:725;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:39838;}i:726;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:39838;}i:727;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:84:"Also the area of study in language parsing and regex is huge. See Nikita's article: ";}i:2;i:39840;}i:728;a:3:{i:0;s:12:"externallink";i:1;a:2:{i:0;s:77:"http://nikic.github.com/2012/06/15/The-true-power-of-regular-expressions.html";i:1;N;}i:2;i:39924;}i:729;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:0:"";}i:2;i:40001;}i:730;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40002;}i:731;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:40002;}i:732;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"Structural Patterns";i:1;i:2;i:2;i:40002;}i:2;i:40002;}i:733;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:40002;}i:734;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40002;}i:735;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:6:"Facade";}i:2;i:40035;}i:736;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40041;}i:737;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40041;}i:738;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:9:"Decorator";}i:2;i:40043;}i:739;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40052;}i:740;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:40054;}i:741;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:19:"Creational Patterns";i:1;i:2;i:2;i:40054;}i:2;i:40054;}i:742;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:40054;}i:743;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40054;}i:744;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:7:"Factory";}i:2;i:40087;}i:745;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:40094;}i:746;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:4:" etc";}i:2;i:40097;}i:747;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40101;}i:748;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:40103;}i:749;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:20:"Behavioural Patterns";i:1;i:2;i:2;i:40103;}i:2;i:40103;}i:750;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:40103;}i:751;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40103;}i:752;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:8:"Observor";}i:2;i:40137;}i:753;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40145;}i:754;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:40147;}i:755;a:3:{i:0;s:6:"header";i:1;a:3:{i:0;s:23:"Artificial Intelligence";i:1;i:2;i:2;i:40147;}i:2;i:40147;}i:756;a:3:{i:0;s:12:"section_open";i:1;a:1:{i:0;i:2;}i:2;i:40147;}i:757;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40147;}i:758;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:23:"Artificial Intelligence";}i:2;i:40184;}i:759;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40207;}i:760;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40207;}i:761;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:16:"machine learning";}i:2;i:40209;}i:762;a:3:{i:0;s:6:"entity";i:1;a:1:{i:0;s:3:"...";}i:2;i:40225;}i:763;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40228;}i:764;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40228;}i:765;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:26:"Operational Transformation";}i:2;i:40230;}i:766;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40256;}i:767;a:3:{i:0;s:6:"p_open";i:1;a:0:{}i:2;i:40256;}i:768;a:3:{i:0;s:5:"cdata";i:1;a:1:{i:0;s:27:"Natural Language Processing";}i:2;i:40258;}i:769;a:3:{i:0;s:7:"p_close";i:1;a:0:{}i:2;i:40285;}i:770;a:3:{i:0;s:13:"section_close";i:1;a:0:{}i:2;i:40285;}i:771;a:3:{i:0;s:12:"document_end";i:1;a:0:{}i:2;i:40285;}}